{
  "version": 3,
  "sources": ["../../../../node_modules/@jspm/core/nodelibs/browser/buffer.js", "../../../../node_modules/csv-parse/lib/api/CsvError.js", "../../../../node_modules/csv-parse/lib/utils/is_object.js", "../../../../node_modules/csv-parse/lib/api/normalize_columns_array.js", "../../../../node_modules/csv-parse/lib/utils/ResizeableBuffer.js", "../../../../node_modules/csv-parse/lib/api/init_state.js", "../../../../node_modules/csv-parse/lib/utils/underscore.js", "../../../../node_modules/csv-parse/lib/api/normalize_options.js", "../../../../node_modules/csv-parse/lib/api/index.js", "../../../../node_modules/csv-parse/lib/sync.js", "../../src/headerDetect.ts", "../../src/delimiterDetect.ts", "../../src/dataParser.ts", "../../src/index.ts"],
  "sourcesContent": ["var exports$3 = {},\n    _dewExec$2 = false;\nfunction dew$2() {\n  if (_dewExec$2) return exports$3;\n  _dewExec$2 = true;\n  exports$3.byteLength = byteLength;\n  exports$3.toByteArray = toByteArray;\n  exports$3.fromByteArray = fromByteArray;\n  var lookup = [];\n  var revLookup = [];\n  var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n  var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  } // Support decoding URL-safe base64 strings, as Node.js does.\n  // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n  revLookup[\"-\".charCodeAt(0)] = 62;\n  revLookup[\"_\".charCodeAt(0)] = 63;\n\n  function getLens(b64) {\n    var len = b64.length;\n\n    if (len % 4 > 0) {\n      throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    } // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [validLen, placeHoldersLen];\n  } // base64 is 4/3 + up to two characters of the original data\n\n\n  function byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n  }\n\n  function _byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n  }\n\n  function toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n\n    for (i = 0; i < len; i += 4) {\n      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n      arr[curByte++] = tmp >> 16 & 255;\n      arr[curByte++] = tmp >> 8 & 255;\n      arr[curByte++] = tmp & 255;\n    }\n\n    if (placeHoldersLen === 2) {\n      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n      arr[curByte++] = tmp & 255;\n    }\n\n    if (placeHoldersLen === 1) {\n      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n      arr[curByte++] = tmp >> 8 & 255;\n      arr[curByte++] = tmp & 255;\n    }\n\n    return arr;\n  }\n\n  function tripletToBase64(num) {\n    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n  }\n\n  function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n\n    for (var i = start; i < end; i += 3) {\n      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n      output.push(tripletToBase64(tmp));\n    }\n\n    return output.join(\"\");\n  }\n\n  function fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n    if (extraBytes === 1) {\n      tmp = uint8[len - 1];\n      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n    } else if (extraBytes === 2) {\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n    }\n\n    return parts.join(\"\");\n  }\n\n  return exports$3;\n}\n\nvar exports$2 = {},\n    _dewExec$1 = false;\nfunction dew$1() {\n  if (_dewExec$1) return exports$2;\n  _dewExec$1 = true;\n\n  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n  exports$2.read = function (buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n\n    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n\n    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    if (e === 0) {\n      e = 1 - eBias;\n    } else if (e === eMax) {\n      return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n      m = m + Math.pow(2, mLen);\n      e = e - eBias;\n    }\n\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n  };\n\n  exports$2.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n\n    if (isNaN(value) || value === Infinity) {\n      m = isNaN(value) ? 1 : 0;\n      e = eMax;\n    } else {\n      e = Math.floor(Math.log(value) / Math.LN2);\n\n      if (value * (c = Math.pow(2, -e)) < 1) {\n        e--;\n        c *= 2;\n      }\n\n      if (e + eBias >= 1) {\n        value += rt / c;\n      } else {\n        value += rt * Math.pow(2, 1 - eBias);\n      }\n\n      if (value * c >= 2) {\n        e++;\n        c /= 2;\n      }\n\n      if (e + eBias >= eMax) {\n        m = 0;\n        e = eMax;\n      } else if (e + eBias >= 1) {\n        m = (value * c - 1) * Math.pow(2, mLen);\n        e = e + eBias;\n      } else {\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n        e = 0;\n      }\n    }\n\n    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}\n\n    e = e << mLen | m;\n    eLen += mLen;\n\n    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}\n\n    buffer[offset + i - d] |= s * 128;\n  };\n\n  return exports$2;\n}\n\nvar exports$1 = {},\n    _dewExec = false;\nfunction dew() {\n  if (_dewExec) return exports$1;\n  _dewExec = true;\n\n  const base64 = dew$2();\n\n  const ieee754 = dew$1();\n\n  const customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") // eslint-disable-line dot-notation\n  : null;\n  exports$1.Buffer = Buffer;\n  exports$1.SlowBuffer = SlowBuffer;\n  exports$1.INSPECT_MAX_BYTES = 50;\n  const K_MAX_LENGTH = 2147483647;\n  exports$1.kMaxLength = K_MAX_LENGTH;\n  /**\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\n   *   === true    Use Uint8Array implementation (fastest)\n   *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n   *               implementation (most compatible, even IE6)\n   *\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n   * Opera 11.6+, iOS 4.2+.\n   *\n   * We report that the browser does not support typed arrays if the are not subclassable\n   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n   * for __proto__ and has a buggy typed array implementation.\n   */\n\n  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(\"This browser lacks typed array (Uint8Array) support which is required by \" + \"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n  }\n\n  function typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n      const arr = new Uint8Array(1);\n      const proto = {\n        foo: function () {\n          return 42;\n        }\n      };\n      Object.setPrototypeOf(proto, Uint8Array.prototype);\n      Object.setPrototypeOf(arr, proto);\n      return arr.foo() === 42;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  Object.defineProperty(Buffer.prototype, \"parent\", {\n    enumerable: true,\n    get: function () {\n      if (!Buffer.isBuffer(this)) return undefined;\n      return this.buffer;\n    }\n  });\n  Object.defineProperty(Buffer.prototype, \"offset\", {\n    enumerable: true,\n    get: function () {\n      if (!Buffer.isBuffer(this)) return undefined;\n      return this.byteOffset;\n    }\n  });\n\n  function createBuffer(length) {\n    if (length > K_MAX_LENGTH) {\n      throw new RangeError(\"The value \\\"\" + length + \"\\\" is invalid for option \\\"size\\\"\");\n    } // Return an augmented `Uint8Array` instance\n\n\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, Buffer.prototype);\n    return buf;\n  }\n  /**\n   * The Buffer constructor returns instances of `Uint8Array` that have their\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n   * returns a single octet.\n   *\n   * The `Uint8Array` prototype remains unmodified.\n   */\n\n\n  function Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === \"number\") {\n      if (typeof encodingOrOffset === \"string\") {\n        throw new TypeError(\"The \\\"string\\\" argument must be of type string. Received type number\");\n      }\n\n      return allocUnsafe(arg);\n    }\n\n    return from(arg, encodingOrOffset, length);\n  }\n\n  Buffer.poolSize = 8192; // not used by this implementation\n\n  function from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n      return fromString(value, encodingOrOffset);\n    }\n\n    if (ArrayBuffer.isView(value)) {\n      return fromArrayView(value);\n    }\n\n    if (value == null) {\n      throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof value);\n    }\n\n    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n\n    if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n\n    if (typeof value === \"number\") {\n      throw new TypeError(\"The \\\"value\\\" argument must not be of type number. Received type number\");\n    }\n\n    const valueOf = value.valueOf && value.valueOf();\n\n    if (valueOf != null && valueOf !== value) {\n      return Buffer.from(valueOf, encodingOrOffset, length);\n    }\n\n    const b = fromObject(value);\n    if (b) return b;\n\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n      return Buffer.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    }\n\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof value);\n  }\n  /**\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n   * if value is a number.\n   * Buffer.from(str[, encoding])\n   * Buffer.from(array)\n   * Buffer.from(buffer)\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\n   **/\n\n\n  Buffer.from = function (value, encodingOrOffset, length) {\n    return from(value, encodingOrOffset, length);\n  }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n  // https://github.com/feross/buffer/pull/148\n\n\n  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n  Object.setPrototypeOf(Buffer, Uint8Array);\n\n  function assertSize(size) {\n    if (typeof size !== \"number\") {\n      throw new TypeError(\"\\\"size\\\" argument must be of type number\");\n    } else if (size < 0) {\n      throw new RangeError(\"The value \\\"\" + size + \"\\\" is invalid for option \\\"size\\\"\");\n    }\n  }\n\n  function alloc(size, fill, encoding) {\n    assertSize(size);\n\n    if (size <= 0) {\n      return createBuffer(size);\n    }\n\n    if (fill !== undefined) {\n      // Only pay attention to encoding if it's a string. This\n      // prevents accidentally sending in a number that would\n      // be interpreted as a start offset.\n      return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n    }\n\n    return createBuffer(size);\n  }\n  /**\n   * Creates a new filled Buffer instance.\n   * alloc(size[, fill[, encoding]])\n   **/\n\n\n  Buffer.alloc = function (size, fill, encoding) {\n    return alloc(size, fill, encoding);\n  };\n\n  function allocUnsafe(size) {\n    assertSize(size);\n    return createBuffer(size < 0 ? 0 : checked(size) | 0);\n  }\n  /**\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n   * */\n\n\n  Buffer.allocUnsafe = function (size) {\n    return allocUnsafe(size);\n  };\n  /**\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n   */\n\n\n  Buffer.allocUnsafeSlow = function (size) {\n    return allocUnsafe(size);\n  };\n\n  function fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n      encoding = \"utf8\";\n    }\n\n    if (!Buffer.isEncoding(encoding)) {\n      throw new TypeError(\"Unknown encoding: \" + encoding);\n    }\n\n    const length = byteLength(string, encoding) | 0;\n    let buf = createBuffer(length);\n    const actual = buf.write(string, encoding);\n\n    if (actual !== length) {\n      // Writing a hex string, for example, that contains invalid characters will\n      // cause everything after the first invalid character to be ignored. (e.g.\n      // 'abxxcd' will be treated as 'ab')\n      buf = buf.slice(0, actual);\n    }\n\n    return buf;\n  }\n\n  function fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : checked(array.length) | 0;\n    const buf = createBuffer(length);\n\n    for (let i = 0; i < length; i += 1) {\n      buf[i] = array[i] & 255;\n    }\n\n    return buf;\n  }\n\n  function fromArrayView(arrayView) {\n    if (isInstance(arrayView, Uint8Array)) {\n      const copy = new Uint8Array(arrayView);\n      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n\n    return fromArrayLike(arrayView);\n  }\n\n  function fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n      throw new RangeError(\"\\\"offset\\\" is outside of buffer bounds\");\n    }\n\n    if (array.byteLength < byteOffset + (length || 0)) {\n      throw new RangeError(\"\\\"length\\\" is outside of buffer bounds\");\n    }\n\n    let buf;\n\n    if (byteOffset === undefined && length === undefined) {\n      buf = new Uint8Array(array);\n    } else if (length === undefined) {\n      buf = new Uint8Array(array, byteOffset);\n    } else {\n      buf = new Uint8Array(array, byteOffset, length);\n    } // Return an augmented `Uint8Array` instance\n\n\n    Object.setPrototypeOf(buf, Buffer.prototype);\n    return buf;\n  }\n\n  function fromObject(obj) {\n    if (Buffer.isBuffer(obj)) {\n      const len = checked(obj.length) | 0;\n      const buf = createBuffer(len);\n\n      if (buf.length === 0) {\n        return buf;\n      }\n\n      obj.copy(buf, 0, 0, len);\n      return buf;\n    }\n\n    if (obj.length !== undefined) {\n      if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n        return createBuffer(0);\n      }\n\n      return fromArrayLike(obj);\n    }\n\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data);\n    }\n  }\n\n  function checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= K_MAX_LENGTH) {\n      throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n    }\n\n    return length | 0;\n  }\n\n  function SlowBuffer(length) {\n    if (+length != length) {\n      // eslint-disable-line eqeqeq\n      length = 0;\n    }\n\n    return Buffer.alloc(+length);\n  }\n\n  Buffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n  };\n\n  Buffer.compare = function compare(a, b) {\n    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n      throw new TypeError(\"The \\\"buf1\\\", \\\"buf2\\\" arguments must be one of type Buffer or Uint8Array\");\n    }\n\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n\n    for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n      if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n      }\n    }\n\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n  };\n\n  Buffer.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  Buffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError(\"\\\"list\\\" argument must be an Array of Buffers\");\n    }\n\n    if (list.length === 0) {\n      return Buffer.alloc(0);\n    }\n\n    let i;\n\n    if (length === undefined) {\n      length = 0;\n\n      for (i = 0; i < list.length; ++i) {\n        length += list[i].length;\n      }\n    }\n\n    const buffer = Buffer.allocUnsafe(length);\n    let pos = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      let buf = list[i];\n\n      if (isInstance(buf, Uint8Array)) {\n        if (pos + buf.length > buffer.length) {\n          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n          buf.copy(buffer, pos);\n        } else {\n          Uint8Array.prototype.set.call(buffer, buf, pos);\n        }\n      } else if (!Buffer.isBuffer(buf)) {\n        throw new TypeError(\"\\\"list\\\" argument must be an Array of Buffers\");\n      } else {\n        buf.copy(buffer, pos);\n      }\n\n      pos += buf.length;\n    }\n\n    return buffer;\n  };\n\n  function byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n      return string.length;\n    }\n\n    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n      return string.byteLength;\n    }\n\n    if (typeof string !== \"string\") {\n      throw new TypeError(\"The \\\"string\\\" argument must be one of type string, Buffer, or ArrayBuffer. \" + \"Received type \" + typeof string);\n    }\n\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n    let loweredCase = false;\n\n    for (;;) {\n      switch (encoding) {\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return len;\n\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8ToBytes(string).length;\n\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return len * 2;\n\n        case \"hex\":\n          return len >>> 1;\n\n        case \"base64\":\n          return base64ToBytes(string).length;\n\n        default:\n          if (loweredCase) {\n            return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n          }\n\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n\n  Buffer.byteLength = byteLength;\n\n  function slowToString(encoding, start, end) {\n    let loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n    if (start === undefined || start < 0) {\n      start = 0;\n    } // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n\n\n    if (start > this.length) {\n      return \"\";\n    }\n\n    if (end === undefined || end > this.length) {\n      end = this.length;\n    }\n\n    if (end <= 0) {\n      return \"\";\n    } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n    end >>>= 0;\n    start >>>= 0;\n\n    if (end <= start) {\n      return \"\";\n    }\n\n    if (!encoding) encoding = \"utf8\";\n\n    while (true) {\n      switch (encoding) {\n        case \"hex\":\n          return hexSlice(this, start, end);\n\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Slice(this, start, end);\n\n        case \"ascii\":\n          return asciiSlice(this, start, end);\n\n        case \"latin1\":\n        case \"binary\":\n          return latin1Slice(this, start, end);\n\n        case \"base64\":\n          return base64Slice(this, start, end);\n\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return utf16leSlice(this, start, end);\n\n        default:\n          if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (encoding + \"\").toLowerCase();\n          loweredCase = true;\n      }\n    }\n  } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n  // reliably in a browserify context because there could be multiple different\n  // copies of the 'buffer' package in use. This method works even for Buffer\n  // instances that were created from another copy of the `buffer` package.\n  // See: https://github.com/feross/buffer/issues/154\n\n\n  Buffer.prototype._isBuffer = true;\n\n  function swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n  }\n\n  Buffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n\n    if (len % 2 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n\n    for (let i = 0; i < len; i += 2) {\n      swap(this, i, i + 1);\n    }\n\n    return this;\n  };\n\n  Buffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n\n    if (len % 4 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n\n    for (let i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n\n    return this;\n  };\n\n  Buffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n\n    if (len % 8 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n\n    for (let i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n\n    return this;\n  };\n\n  Buffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n  };\n\n  Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n  Buffer.prototype.equals = function equals(b) {\n    if (!Buffer.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n  };\n\n  Buffer.prototype.inspect = function inspect() {\n    let str = \"\";\n    const max = exports$1.INSPECT_MAX_BYTES;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max) str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n  };\n\n  if (customInspectSymbol) {\n    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n  }\n\n  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (isInstance(target, Uint8Array)) {\n      target = Buffer.from(target, target.offset, target.byteLength);\n    }\n\n    if (!Buffer.isBuffer(target)) {\n      throw new TypeError(\"The \\\"target\\\" argument must be one of type Buffer or Uint8Array. \" + \"Received type \" + typeof target);\n    }\n\n    if (start === undefined) {\n      start = 0;\n    }\n\n    if (end === undefined) {\n      end = target ? target.length : 0;\n    }\n\n    if (thisStart === undefined) {\n      thisStart = 0;\n    }\n\n    if (thisEnd === undefined) {\n      thisEnd = this.length;\n    }\n\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n      throw new RangeError(\"out of range index\");\n    }\n\n    if (thisStart >= thisEnd && start >= end) {\n      return 0;\n    }\n\n    if (thisStart >= thisEnd) {\n      return -1;\n    }\n\n    if (start >= end) {\n      return 1;\n    }\n\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n\n    for (let i = 0; i < len; ++i) {\n      if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n      }\n    }\n\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n  //\n  // Arguments:\n  // - buffer - a Buffer to search\n  // - val - a string, Buffer, or number\n  // - byteOffset - an index into `buffer`; will be clamped to an int32\n  // - encoding - an optional encoding, relevant is val is a string\n  // - dir - true for indexOf, false for lastIndexOf\n\n\n  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1; // Normalize byteOffset\n\n    if (typeof byteOffset === \"string\") {\n      encoding = byteOffset;\n      byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n      byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n      byteOffset = -2147483648;\n    }\n\n    byteOffset = +byteOffset; // Coerce to Number.\n\n    if (numberIsNaN(byteOffset)) {\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n      byteOffset = dir ? 0 : buffer.length - 1;\n    } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n    if (byteOffset >= buffer.length) {\n      if (dir) return -1;else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n      if (dir) byteOffset = 0;else return -1;\n    } // Normalize val\n\n\n    if (typeof val === \"string\") {\n      val = Buffer.from(val, encoding);\n    } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n    if (Buffer.isBuffer(val)) {\n      // Special case: looking for empty string/buffer always fails\n      if (val.length === 0) {\n        return -1;\n      }\n\n      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n      val = val & 255; // Search for a byte value [0-255]\n\n      if (typeof Uint8Array.prototype.indexOf === \"function\") {\n        if (dir) {\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n        } else {\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n      }\n\n      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n    }\n\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n\n  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n\n    if (encoding !== undefined) {\n      encoding = String(encoding).toLowerCase();\n\n      if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n        if (arr.length < 2 || val.length < 2) {\n          return -1;\n        }\n\n        indexSize = 2;\n        arrLength /= 2;\n        valLength /= 2;\n        byteOffset /= 2;\n      }\n    }\n\n    function read(buf, i) {\n      if (indexSize === 1) {\n        return buf[i];\n      } else {\n        return buf.readUInt16BE(i * indexSize);\n      }\n    }\n\n    let i;\n\n    if (dir) {\n      let foundIndex = -1;\n\n      for (i = byteOffset; i < arrLength; i++) {\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n          if (foundIndex === -1) foundIndex = i;\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n          if (foundIndex !== -1) i -= i - foundIndex;\n          foundIndex = -1;\n        }\n      }\n    } else {\n      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n      for (i = byteOffset; i >= 0; i--) {\n        let found = true;\n\n        for (let j = 0; j < valLength; j++) {\n          if (read(arr, i + j) !== read(val, j)) {\n            found = false;\n            break;\n          }\n        }\n\n        if (found) return i;\n      }\n    }\n\n    return -1;\n  }\n\n  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n  };\n\n  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n  };\n\n  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n  };\n\n  function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n\n    if (!length) {\n      length = remaining;\n    } else {\n      length = Number(length);\n\n      if (length > remaining) {\n        length = remaining;\n      }\n    }\n\n    const strLen = string.length;\n\n    if (length > strLen / 2) {\n      length = strLen / 2;\n    }\n\n    let i;\n\n    for (i = 0; i < length; ++i) {\n      const parsed = parseInt(string.substr(i * 2, 2), 16);\n      if (numberIsNaN(parsed)) return i;\n      buf[offset + i] = parsed;\n    }\n\n    return i;\n  }\n\n  function utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n  }\n\n  function asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n  }\n\n  function base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n  }\n\n  function ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n  }\n\n  Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n      encoding = \"utf8\";\n      length = this.length;\n      offset = 0; // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n      encoding = offset;\n      length = this.length;\n      offset = 0; // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n      offset = offset >>> 0;\n\n      if (isFinite(length)) {\n        length = length >>> 0;\n        if (encoding === undefined) encoding = \"utf8\";\n      } else {\n        encoding = length;\n        length = undefined;\n      }\n    } else {\n      throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n      throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n\n    if (!encoding) encoding = \"utf8\";\n    let loweredCase = false;\n\n    for (;;) {\n      switch (encoding) {\n        case \"hex\":\n          return hexWrite(this, string, offset, length);\n\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Write(this, string, offset, length);\n\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return asciiWrite(this, string, offset, length);\n\n        case \"base64\":\n          // Warning: maxLength not taken into account in base64Write\n          return base64Write(this, string, offset, length);\n\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return ucs2Write(this, string, offset, length);\n\n        default:\n          if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  };\n\n  Buffer.prototype.toJSON = function toJSON() {\n    return {\n      type: \"Buffer\",\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n  };\n\n  function base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n      return base64.fromByteArray(buf);\n    } else {\n      return base64.fromByteArray(buf.slice(start, end));\n    }\n  }\n\n  function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n\n    while (i < end) {\n      const firstByte = buf[i];\n      let codePoint = null;\n      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n\n      if (i + bytesPerSequence <= end) {\n        let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n        switch (bytesPerSequence) {\n          case 1:\n            if (firstByte < 128) {\n              codePoint = firstByte;\n            }\n\n            break;\n\n          case 2:\n            secondByte = buf[i + 1];\n\n            if ((secondByte & 192) === 128) {\n              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n\n              if (tempCodePoint > 127) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n            break;\n\n          case 3:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n\n              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n            break;\n\n          case 4:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            fourthByte = buf[i + 3];\n\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n\n              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n        }\n      }\n\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 65533;\n        bytesPerSequence = 1;\n      } else if (codePoint > 65535) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 65536;\n        res.push(codePoint >>> 10 & 1023 | 55296);\n        codePoint = 56320 | codePoint & 1023;\n      }\n\n      res.push(codePoint);\n      i += bytesPerSequence;\n    }\n\n    return decodeCodePointsArray(res);\n  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n  // the lowest limit is Chrome, with 0x10000 args.\n  // We go 1 magnitude less, for safety\n\n\n  const MAX_ARGUMENTS_LENGTH = 4096;\n\n  function decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n    } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n    let res = \"\";\n    let i = 0;\n\n    while (i < len) {\n      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n\n    return res;\n  }\n\n  function asciiSlice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n\n    for (let i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i] & 127);\n    }\n\n    return ret;\n  }\n\n  function latin1Slice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n\n    for (let i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i]);\n    }\n\n    return ret;\n  }\n\n  function hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = \"\";\n\n    for (let i = start; i < end; ++i) {\n      out += hexSliceLookupTable[buf[i]];\n    }\n\n    return out;\n  }\n\n  function utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = \"\"; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\n    for (let i = 0; i < bytes.length - 1; i += 2) {\n      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n\n    return res;\n  }\n\n  Buffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n\n    if (start < 0) {\n      start += len;\n      if (start < 0) start = 0;\n    } else if (start > len) {\n      start = len;\n    }\n\n    if (end < 0) {\n      end += len;\n      if (end < 0) end = 0;\n    } else if (end > len) {\n      end = len;\n    }\n\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n    Object.setPrototypeOf(newBuf, Buffer.prototype);\n    return newBuf;\n  };\n  /*\n   * Need to make sure that buffer isn't trying to write out of bounds.\n   */\n\n\n  function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n\n  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n\n    while (++i < byteLength && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n\n    return val;\n  };\n\n  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      checkOffset(offset, byteLength, this.length);\n    }\n\n    let val = this[offset + --byteLength];\n    let mul = 1;\n\n    while (byteLength > 0 && (mul *= 256)) {\n      val += this[offset + --byteLength] * mul;\n    }\n\n    return val;\n  };\n\n  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n  };\n\n  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n  };\n\n  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n  };\n\n  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n  };\n\n  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n  };\n\n  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n\n    if (first === undefined || last === undefined) {\n      boundsError(offset, this.length - 8);\n    }\n\n    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n  });\n  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n\n    if (first === undefined || last === undefined) {\n      boundsError(offset, this.length - 8);\n    }\n\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  });\n\n  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n\n    while (++i < byteLength && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n\n    mul *= 128;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n  };\n\n  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n\n    while (i > 0 && (mul *= 256)) {\n      val += this[offset + --i] * mul;\n    }\n\n    mul *= 128;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n  };\n\n  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 128)) return this[offset];\n    return (255 - this[offset] + 1) * -1;\n  };\n\n  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n\n  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n\n  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n  };\n\n  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n  };\n\n  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n\n    if (first === undefined || last === undefined) {\n      boundsError(offset, this.length - 8);\n    }\n\n    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow\n\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n  });\n  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n\n    if (first === undefined || last === undefined) {\n      boundsError(offset, this.length - 8);\n    }\n\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n  });\n\n  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, true, 23, 4);\n  };\n\n  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, false, 23, 4);\n  };\n\n  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, true, 52, 8);\n  };\n\n  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, false, 52, 8);\n  };\n\n  function checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer.isBuffer(buf)) throw new TypeError(\"\\\"buffer\\\" argument must be a Buffer instance\");\n    if (value > max || value < min) throw new RangeError(\"\\\"value\\\" argument is out of bounds\");\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n  }\n\n  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 255;\n\n    while (++i < byteLength && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 255;\n\n    while (--i >= 0 && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n\n  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n\n  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n\n  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 255;\n    return offset + 4;\n  };\n\n  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n\n  function wrtBigUInt64LE(buf, value, offset, min, max) {\n    checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(4294967295));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n  }\n\n  function wrtBigUInt64BE(buf, value, offset, min, max) {\n    checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(4294967295));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n  }\n\n  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  });\n  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  });\n\n  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      const limit = Math.pow(2, 8 * byteLength - 1);\n      checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 255;\n\n    while (++i < byteLength && (mul *= 256)) {\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n        sub = 1;\n      }\n\n      this[offset + i] = (value / mul >> 0) - sub & 255;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      const limit = Math.pow(2, 8 * byteLength - 1);\n      checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 255;\n\n    while (--i >= 0 && (mul *= 256)) {\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n        sub = 1;\n      }\n\n      this[offset + i] = (value / mul >> 0) - sub & 255;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);\n    if (value < 0) value = 255 + value + 1;\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n\n  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n\n  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n\n  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n  };\n\n  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    if (value < 0) value = 4294967295 + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n\n  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n    return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  });\n  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n    return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  });\n\n  function checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n  }\n\n  function writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 4);\n    }\n\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n  }\n\n  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n  };\n\n  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n  };\n\n  function writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 8);\n    }\n\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n  }\n\n  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n  };\n\n  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n  Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!Buffer.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n    if (targetStart < 0) {\n      throw new RangeError(\"targetStart out of bounds\");\n    }\n\n    if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\"); // Are we oob?\n\n    if (end > this.length) end = this.length;\n\n    if (target.length - targetStart < end - start) {\n      end = target.length - targetStart + start;\n    }\n\n    const len = end - start;\n\n    if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n      // Use built-in when available, missing from IE11\n      this.copyWithin(targetStart, start, end);\n    } else {\n      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    }\n\n    return len;\n  }; // Usage:\n  //    buffer.fill(number[, offset[, end]])\n  //    buffer.fill(buffer[, offset[, end]])\n  //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n  Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n      if (typeof start === \"string\") {\n        encoding = start;\n        start = 0;\n        end = this.length;\n      } else if (typeof end === \"string\") {\n        encoding = end;\n        end = this.length;\n      }\n\n      if (encoding !== undefined && typeof encoding !== \"string\") {\n        throw new TypeError(\"encoding must be a string\");\n      }\n\n      if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n\n      if (val.length === 1) {\n        const code = val.charCodeAt(0);\n\n        if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n          // Fast path: If `val` fits into a single byte, use that numeric value.\n          val = code;\n        }\n      }\n    } else if (typeof val === \"number\") {\n      val = val & 255;\n    } else if (typeof val === \"boolean\") {\n      val = Number(val);\n    } // Invalid ranges are not set to a default, so can range check early.\n\n\n    if (start < 0 || this.length < start || this.length < end) {\n      throw new RangeError(\"Out of range index\");\n    }\n\n    if (end <= start) {\n      return this;\n    }\n\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n\n    if (typeof val === \"number\") {\n      for (i = start; i < end; ++i) {\n        this[i] = val;\n      }\n    } else {\n      const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n      const len = bytes.length;\n\n      if (len === 0) {\n        throw new TypeError(\"The value \\\"\" + val + \"\\\" is invalid for argument \\\"value\\\"\");\n      }\n\n      for (i = 0; i < end - start; ++i) {\n        this[i + start] = bytes[i % len];\n      }\n    }\n\n    return this;\n  }; // CUSTOM ERRORS\n  // =============\n  // Simplified versions from Node, changed for Buffer-only usage\n\n\n  const errors = {};\n\n  function E(sym, getMessage, Base) {\n    errors[sym] = class NodeError extends Base {\n      constructor() {\n        super();\n        Object.defineProperty(this, \"message\", {\n          value: getMessage.apply(this, arguments),\n          writable: true,\n          configurable: true\n        }); // Add the error code to the name to include it in the stack trace.\n\n        this.name = `${this.name} [${sym}]`; // Access the stack to generate the error message including the error code\n        // from the name.\n\n        this.stack; // eslint-disable-line no-unused-expressions\n        // Reset the name to the actual name.\n\n        delete this.name;\n      }\n\n      get code() {\n        return sym;\n      }\n\n      set code(value) {\n        Object.defineProperty(this, \"code\", {\n          configurable: true,\n          enumerable: true,\n          value,\n          writable: true\n        });\n      }\n\n      toString() {\n        return `${this.name} [${sym}]: ${this.message}`;\n      }\n\n    };\n  }\n\n  E(\"ERR_BUFFER_OUT_OF_BOUNDS\", function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`;\n    }\n\n    return \"Attempt to access memory outside buffer bounds\";\n  }, RangeError);\n  E(\"ERR_INVALID_ARG_TYPE\", function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n  }, TypeError);\n  E(\"ERR_OUT_OF_RANGE\", function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === \"bigint\") {\n      received = String(input);\n\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received);\n      }\n\n      received += \"n\";\n    }\n\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }, RangeError);\n\n  function addNumericalSeparator(val) {\n    let res = \"\";\n    let i = val.length;\n    const start = val[0] === \"-\" ? 1 : 0;\n\n    for (; i >= start + 4; i -= 3) {\n      res = `_${val.slice(i - 3, i)}${res}`;\n    }\n\n    return `${val.slice(0, i)}${res}`;\n  } // CHECK FUNCTIONS\n  // ===============\n\n\n  function checkBounds(buf, offset, byteLength) {\n    validateNumber(offset, \"offset\");\n\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n      boundsError(offset, buf.length - (byteLength + 1));\n    }\n  }\n\n  function checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n      const n = typeof min === \"bigint\" ? \"n\" : \"\";\n      let range;\n\n      if (byteLength > 3) {\n        if (min === 0 || min === BigInt(0)) {\n          range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n        } else {\n          range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n        }\n      } else {\n        range = `>= ${min}${n} and <= ${max}${n}`;\n      }\n\n      throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n    }\n\n    checkBounds(buf, offset, byteLength);\n  }\n\n  function validateNumber(value, name) {\n    if (typeof value !== \"number\") {\n      throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n  }\n\n  function boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n      validateNumber(value, type);\n      throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n    }\n\n    if (length < 0) {\n      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n\n    throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", `>= ${type ? 1 : 0} and <= ${length}`, value);\n  } // HELPER FUNCTIONS\n  // ================\n\n\n  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n  function base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split(\"=\")[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n    str = str.trim().replace(INVALID_BASE64_RE, \"\"); // Node converts strings with length < 2 to ''\n\n    if (str.length < 2) return \"\"; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n    while (str.length % 4 !== 0) {\n      str = str + \"=\";\n    }\n\n    return str;\n  }\n\n  function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n\n    for (let i = 0; i < length; ++i) {\n      codePoint = string.charCodeAt(i); // is surrogate component\n\n      if (codePoint > 55295 && codePoint < 57344) {\n        // last char was a lead\n        if (!leadSurrogate) {\n          // no lead yet\n          if (codePoint > 56319) {\n            // unexpected trail\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n            continue;\n          } else if (i + 1 === length) {\n            // unpaired lead\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n            continue;\n          } // valid lead\n\n\n          leadSurrogate = codePoint;\n          continue;\n        } // 2 leads in a row\n\n\n        if (codePoint < 56320) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n          leadSurrogate = codePoint;\n          continue;\n        } // valid surrogate pair\n\n\n        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n      } else if (leadSurrogate) {\n        // valid bmp char, but last char was a lead\n        if ((units -= 3) > -1) bytes.push(239, 191, 189);\n      }\n\n      leadSurrogate = null; // encode utf8\n\n      if (codePoint < 128) {\n        if ((units -= 1) < 0) break;\n        bytes.push(codePoint);\n      } else if (codePoint < 2048) {\n        if ((units -= 2) < 0) break;\n        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n      } else if (codePoint < 65536) {\n        if ((units -= 3) < 0) break;\n        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else if (codePoint < 1114112) {\n        if ((units -= 4) < 0) break;\n        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else {\n        throw new Error(\"Invalid code point\");\n      }\n    }\n\n    return bytes;\n  }\n\n  function asciiToBytes(str) {\n    const byteArray = [];\n\n    for (let i = 0; i < str.length; ++i) {\n      // Node's code seems to be doing this and not & 0x7F..\n      byteArray.push(str.charCodeAt(i) & 255);\n    }\n\n    return byteArray;\n  }\n\n  function utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n\n    for (let i = 0; i < str.length; ++i) {\n      if ((units -= 2) < 0) break;\n      c = str.charCodeAt(i);\n      hi = c >> 8;\n      lo = c % 256;\n      byteArray.push(lo);\n      byteArray.push(hi);\n    }\n\n    return byteArray;\n  }\n\n  function base64ToBytes(str) {\n    return base64.toByteArray(base64clean(str));\n  }\n\n  function blitBuffer(src, dst, offset, length) {\n    let i;\n\n    for (i = 0; i < length; ++i) {\n      if (i + offset >= dst.length || i >= src.length) break;\n      dst[i + offset] = src[i];\n    }\n\n    return i;\n  } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n  // the `instanceof` check but they should be treated as of that type.\n  // See: https://github.com/feross/buffer/issues/166\n\n\n  function isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n  }\n\n  function numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj; // eslint-disable-line no-self-compare\n  } // Create lookup table for `toString('hex')`\n  // See: https://github.com/feross/buffer/issues/219\n\n\n  const hexSliceLookupTable = function () {\n    const alphabet = \"0123456789abcdef\";\n    const table = new Array(256);\n\n    for (let i = 0; i < 16; ++i) {\n      const i16 = i * 16;\n\n      for (let j = 0; j < 16; ++j) {\n        table[i16 + j] = alphabet[i] + alphabet[j];\n      }\n    }\n\n    return table;\n  }(); // Return not function with Error if BigInt not supported\n\n\n  function defineBigIntMethod(fn) {\n    return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n  }\n\n  function BufferBigIntNotDefined() {\n    throw new Error(\"BigInt not supported\");\n  }\n\n  return exports$1;\n}\n\nconst exports = dew();\nexports['Buffer']; exports['SlowBuffer']; exports['INSPECT_MAX_BYTES']; exports['kMaxLength'];\n\nvar Buffer = exports.Buffer;\r\nvar INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;\r\nvar kMaxLength = exports.kMaxLength;\n\nexport { Buffer, INSPECT_MAX_BYTES, exports as default, kMaxLength };\n", "\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ').trim();\n    super(message);\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nexport {CsvError};\n", "\nconst is_object = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj));\n};\n\nexport {is_object};\n", "\nimport {CsvError} from './CsvError.js';\nimport {is_object} from '../utils/is_object.js';\n\nconst normalize_columns_array = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i];\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true };\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column };\n    }else if(is_object(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ]);\n      }\n      normalizedColumns[i] = column;\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ]);\n    }\n  }\n  return normalizedColumns;\n};\n\nexport {normalize_columns_array};\n", "\nclass ResizeableBuffer{\n  constructor(size=100){\n    this.size = size;\n    this.length = 0;\n    this.buf = Buffer.allocUnsafe(size);\n  }\n  prepend(val){\n    if(Buffer.isBuffer(val)){\n      const length = this.length + val.length;\n      if(length >= this.size){\n        this.resize();\n        if(length >= this.size){\n          throw Error('INVALID_BUFFER_STATE');\n        }\n      }\n      const buf = this.buf;\n      this.buf = Buffer.allocUnsafe(this.size);\n      val.copy(this.buf, 0);\n      buf.copy(this.buf, val.length);\n      this.length += val.length;\n    }else{\n      const length = this.length++;\n      if(length === this.size){\n        this.resize();\n      }\n      const buf = this.clone();\n      this.buf[0] = val;\n      buf.copy(this.buf,1, 0, length);\n    }\n  }\n  append(val){\n    const length = this.length++;\n    if(length === this.size){\n      this.resize();\n    }\n    this.buf[length] = val;\n  }\n  clone(){\n    return Buffer.from(this.buf.slice(0, this.length));\n  }\n  resize(){\n    const length = this.length;\n    this.size = this.size * 2;\n    const buf = Buffer.allocUnsafe(this.size);\n    this.buf.copy(buf,0, 0, length);\n    this.buf = buf;\n  }\n  toString(encoding){\n    if(encoding){\n      return this.buf.slice(0, this.length).toString(encoding);\n    }else{\n      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));\n    }\n  }\n  toJSON(){\n    return this.toString('utf8');\n  }\n  reset(){\n    this.length = 0;\n  }\n}\n\nexport default ResizeableBuffer;\n", "\nimport ResizeableBuffer from '../utils/ResizeableBuffer.js';\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst np = 12;\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexad\u00E9cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\nconst space = 32;\nconst tab = 9;\n\nconst init_state = function(options){\n  return {\n    bomSkipped: false,\n    bufBytesStart: 0,\n    castField: options.cast_function,\n    commenting: false,\n    // Current error encountered by a record\n    error: undefined,\n    enabled: options.from_line === 1,\n    escaping: false,\n    escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n    // columns can be `false`, `true`, `Array`\n    expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n    field: new ResizeableBuffer(20),\n    firstLineToHeaders: options.cast_first_line_to_header,\n    needMoreDataSize: Math.max(\n      // Skip if the remaining buffer smaller than comment\n      options.comment !== null ? options.comment.length : 0,\n      // Skip if the remaining buffer can be delimiter\n      ...options.delimiter.map((delimiter) => delimiter.length),\n      // Skip if the remaining buffer can be escape sequence\n      options.quote !== null ? options.quote.length : 0,\n    ),\n    previousBuf: undefined,\n    quoting: false,\n    stop: false,\n    rawBuffer: new ResizeableBuffer(100),\n    record: [],\n    recordHasError: false,\n    record_length: 0,\n    recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v) => v.length)),\n    trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n    wasQuoting: false,\n    wasRowDelimiter: false,\n    timchars: [\n      Buffer.from(Buffer.from([cr], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([nl], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([np], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([space], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([tab], 'utf8').toString(), options.encoding),\n    ]\n  };\n};\n\nexport {init_state};\n", "\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase();\n  });\n};\n\nexport {underscore};\n", "\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {CsvError} from './CsvError.js';\nimport {underscore} from '../utils/underscore.js';\n\nconst normalize_options = function(opts){\n  const options = {};\n  // Merge with user options\n  for(const opt in opts){\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `encoding`\n  // Note: defined first because other options depends on it\n  // to convert chars/strings into buffers.\n  if(options.encoding === undefined || options.encoding === true){\n    options.encoding = 'utf8';\n  }else if(options.encoding === null || options.encoding === false){\n    options.encoding = null;\n  }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n    throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n      'Invalid option encoding:',\n      'encoding must be a string or null to return a buffer,',\n      `got ${JSON.stringify(options.encoding)}`\n    ], options);\n  }\n  // Normalize option `bom`\n  if(options.bom === undefined || options.bom === null || options.bom === false){\n    options.bom = false;\n  }else if(options.bom !== true){\n    throw new CsvError('CSV_INVALID_OPTION_BOM', [\n      'Invalid option bom:', 'bom must be true,',\n      `got ${JSON.stringify(options.bom)}`\n    ], options);\n  }\n  // Normalize option `cast`\n  options.cast_function = null;\n  if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n    options.cast = undefined;\n  }else if(typeof options.cast === 'function'){\n    options.cast_function = options.cast;\n    options.cast = true;\n  }else if(options.cast !== true){\n    throw new CsvError('CSV_INVALID_OPTION_CAST', [\n      'Invalid option cast:', 'cast must be true or a function,',\n      `got ${JSON.stringify(options.cast)}`\n    ], options);\n  }\n  // Normalize option `cast_date`\n  if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n    options.cast_date = false;\n  }else if(options.cast_date === true){\n    options.cast_date = function(value){\n      const date = Date.parse(value);\n      return !isNaN(date) ? new Date(date) : value;\n    };\n  }else if (typeof options.cast_date !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n      'Invalid option cast_date:', 'cast_date must be true or a function,',\n      `got ${JSON.stringify(options.cast_date)}`\n    ], options);\n  }\n  // Normalize option `columns`\n  options.cast_first_line_to_header = null;\n  if(options.columns === true){\n    // Fields in the first line are converted as-is to columns\n    options.cast_first_line_to_header = undefined;\n  }else if(typeof options.columns === 'function'){\n    options.cast_first_line_to_header = options.columns;\n    options.columns = true;\n  }else if(Array.isArray(options.columns)){\n    options.columns = normalize_columns_array(options.columns);\n  }else if(options.columns === undefined || options.columns === null || options.columns === false){\n    options.columns = false;\n  }else{\n    throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n      'Invalid option columns:',\n      'expect an array, a function or true,',\n      `got ${JSON.stringify(options.columns)}`\n    ], options);\n  }\n  // Normalize option `group_columns_by_name`\n  if(options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false){\n    options.group_columns_by_name = false;\n  }else if(options.group_columns_by_name !== true){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'expect an boolean,',\n      `got ${JSON.stringify(options.group_columns_by_name)}`\n    ], options);\n  }else if(options.columns === false){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'the `columns` mode must be activated.'\n    ], options);\n  }\n  // Normalize option `comment`\n  if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n    options.comment = null;\n  }else{\n    if(typeof options.comment === 'string'){\n      options.comment = Buffer.from(options.comment, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.comment)){\n      throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n        'Invalid option comment:',\n        'comment must be a buffer or a string,',\n        `got ${JSON.stringify(options.comment)}`\n      ], options);\n    }\n  }\n  // Normalize option `comment_no_infix`\n  if(options.comment_no_infix === undefined || options.comment_no_infix === null || options.comment_no_infix === false){\n    options.comment_no_infix = false;\n  }else if(options.comment_no_infix !== true){\n    throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n      'Invalid option comment_no_infix:',\n      'value must be a boolean,',\n      `got ${JSON.stringify(options.comment_no_infix)}`\n    ], options);\n  }\n  // Normalize option `delimiter`\n  const delimiter_json = JSON.stringify(options.delimiter);\n  if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n  if(options.delimiter.length === 0){\n    throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n      'Invalid option delimiter:',\n      'delimiter must be a non empty string or buffer or array of string|buffer,',\n      `got ${delimiter_json}`\n    ], options);\n  }\n  options.delimiter = options.delimiter.map(function(delimiter){\n    if(delimiter === undefined || delimiter === null || delimiter === false){\n      return Buffer.from(',', options.encoding);\n    }\n    if(typeof delimiter === 'string'){\n      delimiter = Buffer.from(delimiter, options.encoding);\n    }\n    if(!Buffer.isBuffer(delimiter) || delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options);\n    }\n    return delimiter;\n  });\n  // Normalize option `escape`\n  if(options.escape === undefined || options.escape === true){\n    options.escape = Buffer.from('\"', options.encoding);\n  }else if(typeof options.escape === 'string'){\n    options.escape = Buffer.from(options.escape, options.encoding);\n  }else if (options.escape === null || options.escape === false){\n    options.escape = null;\n  }\n  if(options.escape !== null){\n    if(!Buffer.isBuffer(options.escape)){\n      throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n    }\n  }\n  // Normalize option `from`\n  if(options.from === undefined || options.from === null){\n    options.from = 1;\n  }else{\n    if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n      options.from = parseInt(options.from);\n    }\n    if(Number.isInteger(options.from)){\n      if(options.from < 0){\n        throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n    }\n  }\n  // Normalize option `from_line`\n  if(options.from_line === undefined || options.from_line === null){\n    options.from_line = 1;\n  }else{\n    if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n      options.from_line = parseInt(options.from_line);\n    }\n    if(Number.isInteger(options.from_line)){\n      if(options.from_line <= 0){\n        throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n    }\n  }\n  // Normalize options `ignore_last_delimiters`\n  if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n    options.ignore_last_delimiters = false;\n  }else if(typeof options.ignore_last_delimiters === 'number'){\n    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n    if(options.ignore_last_delimiters === 0){\n      options.ignore_last_delimiters = false;\n    }\n  }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n    throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n      'Invalid option `ignore_last_delimiters`:',\n      'the value must be a boolean value or an integer,',\n      `got ${JSON.stringify(options.ignore_last_delimiters)}`\n    ], options);\n  }\n  if(options.ignore_last_delimiters === true && options.columns === false){\n    throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n      'The option `ignore_last_delimiters`',\n      'requires the activation of the `columns` option'\n    ], options);\n  }\n  // Normalize option `info`\n  if(options.info === undefined || options.info === null || options.info === false){\n    options.info = false;\n  }else if(options.info !== true){\n    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n  }\n  // Normalize option `max_record_size`\n  if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n    options.max_record_size = 0;\n  }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n    // Great, nothing to do\n  }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n    options.max_record_size = parseInt(options.max_record_size);\n  }else{\n    throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n  }\n  // Normalize option `objname`\n  if(options.objname === undefined || options.objname === null || options.objname === false){\n    options.objname = undefined;\n  }else if(Buffer.isBuffer(options.objname)){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty buffer`);\n    }\n    if(options.encoding === null){\n      // Don't call `toString`, leave objname as a buffer\n    }else{\n      options.objname = options.objname.toString(options.encoding);\n    }\n  }else if(typeof options.objname === 'string'){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty string`);\n    }\n    // Great, nothing to do\n  }else if(typeof options.objname === 'number'){\n    // if(options.objname.length === 0){\n    //   throw new Error(`Invalid Option: objname must be a non empty string`);\n    // }\n    // Great, nothing to do\n  }else{\n    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n  }\n  if(options.objname !== undefined){\n    if(typeof options.objname === 'number'){\n      if(options.columns !== false){\n        throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');\n      }\n    }else{ // A string or a buffer\n      if(options.columns === false){\n        throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');\n      }\n    }\n  }\n  // Normalize option `on_record`\n  if(options.on_record === undefined || options.on_record === null){\n    options.on_record = undefined;\n  }else if(typeof options.on_record !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n      'Invalid option `on_record`:',\n      'expect a function,',\n      `got ${JSON.stringify(options.on_record)}`\n    ], options);\n  }\n  // Normalize option `quote`\n  if(options.quote === null || options.quote === false || options.quote === ''){\n    options.quote = null;\n  }else{\n    if(options.quote === undefined || options.quote === true){\n      options.quote = Buffer.from('\"', options.encoding);\n    }else if(typeof options.quote === 'string'){\n      options.quote = Buffer.from(options.quote, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.quote)){\n      throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n    }\n  }\n  // Normalize option `raw`\n  if(options.raw === undefined || options.raw === null || options.raw === false){\n    options.raw = false;\n  }else if(options.raw !== true){\n    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n  }\n  // Normalize option `record_delimiter`\n  if(options.record_delimiter === undefined){\n    options.record_delimiter = [];\n  }else if(typeof options.record_delimiter === 'string' || Buffer.isBuffer(options.record_delimiter)){\n    if(options.record_delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer,',\n        `got ${JSON.stringify(options.record_delimiter)}`\n      ], options);\n    }\n    options.record_delimiter = [options.record_delimiter];\n  }else if(!Array.isArray(options.record_delimiter)){\n    throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n      'Invalid option `record_delimiter`:',\n      'value must be a string, a buffer or array of string|buffer,',\n      `got ${JSON.stringify(options.record_delimiter)}`\n    ], options);\n  }\n  options.record_delimiter = options.record_delimiter.map(function(rd, i){\n    if(typeof rd !== 'string' && ! Buffer.isBuffer(rd)){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a string, a buffer or array of string|buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }else if(rd.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }\n    if(typeof rd === 'string'){\n      rd = Buffer.from(rd, options.encoding);\n    }\n    return rd;\n  });\n  // Normalize option `relax_column_count`\n  if(typeof options.relax_column_count === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n    options.relax_column_count = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n  }\n  if(typeof options.relax_column_count_less === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n    options.relax_column_count_less = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n  }\n  if(typeof options.relax_column_count_more === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n    options.relax_column_count_more = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n  }\n  // Normalize option `relax_quotes`\n  if(typeof options.relax_quotes === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_quotes === undefined || options.relax_quotes === null){\n    options.relax_quotes = false;\n  }else{\n    throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);\n  }\n  // Normalize option `skip_empty_lines`\n  if(typeof options.skip_empty_lines === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n    options.skip_empty_lines = false;\n  }else{\n    throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n  }\n  // Normalize option `skip_records_with_empty_values`\n  if(typeof options.skip_records_with_empty_values === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null){\n    options.skip_records_with_empty_values = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);\n  }\n  // Normalize option `skip_records_with_error`\n  if(typeof options.skip_records_with_error === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_error === undefined || options.skip_records_with_error === null){\n    options.skip_records_with_error = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);\n  }\n  // Normalize option `rtrim`\n  if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n    options.rtrim = false;\n  }else if(options.rtrim !== true){\n    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n  }\n  // Normalize option `ltrim`\n  if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n    options.ltrim = false;\n  }else if(options.ltrim !== true){\n    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n  }\n  // Normalize option `trim`\n  if(options.trim === undefined || options.trim === null || options.trim === false){\n    options.trim = false;\n  }else if(options.trim !== true){\n    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n  }\n  // Normalize options `trim`, `ltrim` and `rtrim`\n  if(options.trim === true && opts.ltrim !== false){\n    options.ltrim = true;\n  }else if(options.ltrim !== true){\n    options.ltrim = false;\n  }\n  if(options.trim === true && opts.rtrim !== false){\n    options.rtrim = true;\n  }else if(options.rtrim !== true){\n    options.rtrim = false;\n  }\n  // Normalize option `to`\n  if(options.to === undefined || options.to === null){\n    options.to = -1;\n  }else{\n    if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n      options.to = parseInt(options.to);\n    }\n    if(Number.isInteger(options.to)){\n      if(options.to <= 0){\n        throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n    }\n  }\n  // Normalize option `to_line`\n  if(options.to_line === undefined || options.to_line === null){\n    options.to_line = -1;\n  }else{\n    if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n      options.to_line = parseInt(options.to_line);\n    }\n    if(Number.isInteger(options.to_line)){\n      if(options.to_line <= 0){\n        throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n    }\n  }\n  return options;\n};\n\nexport {normalize_options};\n", "\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {init_state} from './init_state.js';\nimport {normalize_options} from './normalize_options.js';\nimport {CsvError} from './CsvError.js';\n\nconst isRecordEmpty = function(record){\n  return record.every((field) => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexad\u00E9cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function(original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function(i, bufLen, end){\n      if(end) return false;\n      const {encoding, escape, quote} = this.options;\n      const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? ((escape === null ? 0 : escape.length) + quote.length) : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function(nextBuf, end, push, close){\n      const {bom, comment_no_infix, encoding, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;\n      let {comment, escape, quote, record_delimiter} = this.options;\n      const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;\n      let buf;\n      if(previousBuf === undefined){\n        if(nextBuf === undefined){\n          // Handle empty string\n          close();\n          return;\n        }else{\n          buf = nextBuf;\n        }\n      }else if(previousBuf !== undefined && nextBuf === undefined){\n        buf = previousBuf;\n      }else{\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if(bomSkipped === false){\n        if(bom === false){\n          this.state.bomSkipped = true;\n        }else if(buf.length < 3){\n          // No enough data\n          if(end === false){\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        }else{\n          for(const encoding in boms){\n            if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({...this.original_options, encoding: encoding});\n              // Options will re-evaluate the Buffer with the new encoding\n              ({comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for(pos = 0; pos < bufLen; pos++){\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if(this.__needMoreData(pos, bufLen, end)){\n          break;\n        }\n        if(this.state.wasRowDelimiter === true){\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if(to_line !== -1 && this.info.lines > to_line){\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if(this.state.quoting === false && record_delimiter.length === 0){\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if(record_delimiterCount){\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if(raw === true){\n          rawBuffer.append(chr);\n        }\n        if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if(this.state.escaping === true){\n          this.state.escaping = false;\n        }else{\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n            if(escapeIsQuote){\n              if(this.__isQuote(buf, pos+escape.length)){\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            }else{\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if(this.state.commenting === false && this.__isQuote(buf, pos)){\n            if(this.state.quoting === true){\n              const nextChr = buf[pos+quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n                pos += escape.length - 1;\n              }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              }else if(relax_quotes === false){\n                const err = this.__error(\n                  new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                    'Invalid Closing Quote:',\n                    `got \"${String.fromCharCode(nextChr)}\"`,\n                    `at line ${this.info.lines}`,\n                    'instead of delimiter, record delimiter, trimable character',\n                    '(if activated) or comment',\n                  ], this.options, this.__infoField())\n                );\n                if(err !== undefined) return err;\n              }else{\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            }else{\n              if(this.state.field.length !== 0){\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if(relax_quotes === false){\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError('INVALID_OPENING_QUOTE', [\n                      'Invalid Opening Quote:',\n                      `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                      bom ? `(${bom} bom)` : undefined\n                    ], this.options, info, {\n                      field: this.state.field,\n                    })\n                  );\n                  if(err !== undefined) return err;\n                }\n              }else{\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if(this.state.quoting === false){\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if(recordDelimiterLength !== 0){\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);\n              if(skipCommentLine){\n                this.info.comment_lines++;\n                // Skip full comment line\n              }else{\n                // Activate records emition if above from_line\n                if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if(errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if(errRecord !== undefined) return errRecord;\n                if(to !== -1 && this.info.records >= to){\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if(this.state.commenting){\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if(commentCount !== 0 && (comment_no_infix === false || this.state.field.length === 0)){\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if(delimiterLength !== 0){\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if(errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if(this.state.commenting === false){\n          if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n            return this.__error(\n              new CsvError('CSV_MAX_RECORD_SIZE', [\n                'Max Record Size:',\n                'record exceed the maximum number of tolerated bytes',\n                `of ${max_record_size}`,\n                `at line ${this.info.lines}`,\n              ], this.options, this.__infoField())\n            );\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if(lappend === true && rappend === true){\n          this.state.field.append(chr);\n        }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){\n          return this.__error(\n            new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n              'Invalid Closing Quote:',\n              'found non trimable byte after quote',\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n        }else{\n          if(lappend === false){\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if(end === true){\n        // Ensure we are not ending in a quoting state\n        if(this.state.quoting === true){\n          const err = this.__error(\n            new CsvError('CSV_QUOTE_NOT_CLOSED', [\n              'Quote Not Closed:',\n              `the parsing is finished with an opening quote at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n          if(err !== undefined) return err;\n        }else{\n          // Skip last line if it has no characters\n          if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if(errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if(errRecord !== undefined) return errRecord;\n          }else if(this.state.wasRowDelimiter === true){\n            this.info.empty_lines++;\n          }else if(this.state.commenting === true){\n            this.info.comment_lines++;\n          }\n        }\n      }else{\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function(push){\n      const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;\n      const {enabled, record} = this.state;\n      if(enabled === false){\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if(columns === true){\n        if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if(columns === false && this.info.records === 0){\n        this.state.expectedRecordLength = recordLength;\n      }\n      if(recordLength !== this.state.expectedRecordLength){\n        const err = columns === false ?\n          new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [\n            'Invalid Record Length:',\n            `expect ${this.state.expectedRecordLength},`,\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          })\n          :\n          new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', [\n            'Invalid Record Length:',\n            `columns length is ${columns.length},`, // rename columns\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          });\n        if(relax_column_count === true ||\n          (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){\n          this.info.invalid_field_length++;\n          this.state.error = err;\n        // Error is undefined with skip_records_with_error\n        }else{\n          const finalErr = this.__error(err);\n          if(finalErr) return finalErr;\n        }\n      }\n      if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord();\n        return;\n      }\n      if(this.state.recordHasError === true){\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if(from === 1 || this.info.records >= from){\n        const {objname} = this.options;\n        // With columns, records are object\n        if(columns !== false){\n          const obj = {};\n          // Transform record array to an object\n          for(let i = 0, l = record.length; i < l; i++){\n            if(columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        // Without columns, records are array\n        }else{\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: record},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function(record){\n      const {firstLineToHeaders} = this.state;\n      try{\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if(!Array.isArray(headers)){\n          return this.__error(\n            new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n              'Invalid Column Mapping:',\n              'expect an array from column function,',\n              `got ${JSON.stringify(headers)}`\n            ], this.options, this.__infoField(), {\n              headers: headers,\n            })\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      }catch(err){\n        return err;\n      }\n    },\n    __resetRecord: function(){\n      if(this.options.raw === true){\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function(){\n      const {cast, encoding, rtrim, max_record_size} = this.options;\n      const {enabled, wasQuoting} = this.state;\n      // Short circuit for the from_line options\n      if(enabled === false){\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if(rtrim === true && wasQuoting === false){\n        field = field.trimRight();\n      }\n      if(cast === true){\n        const [err, f] = this.__cast(field);\n        if(err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if(max_record_size !== 0 && typeof field === 'string'){\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function(){\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function(record, push){\n      const {on_record} = this.options;\n      if(on_record !== undefined){\n        const info = this.__infoRecord();\n        try{\n          record = on_record.call(null, record, info);\n        }catch(err){\n          return err;\n        }\n        if(record === undefined || record === null){ return; }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function(field){\n      const {columns, relax_column_count} = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){\n        return [undefined, undefined];\n      }\n      if(this.state.castField !== null){\n        try{\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        }catch(err){\n          return [err];\n        }\n      }\n      if(this.__isFloat(field)){\n        return [undefined, parseFloat(field)];\n      }else if(this.options.cast_date !== false){\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function(buf, pos){\n      const isTrim = (buf, pos) => {\n        const {timchars} = this.state;\n        loop1: for(let i = 0; i < timchars.length; i++){\n          const timchar = timchars[i];\n          for(let j = 0; j < timchar.length; j++){\n            if(timchar[j] !== buf[pos+j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function(value){\n      return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){\n      if(sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for(let i = 1; i < sourceLength; i++){\n        if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function(buf, pos, chr){\n      const {delimiter, ignore_last_delimiters} = this.options;\n      if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n        return 0;\n      }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n        return 0;\n      }\n      loop1: for(let i = 0; i < delimiter.length; i++){\n        const del = delimiter[i];\n        if(del[0] === chr){\n          for(let j = 1; j < del.length; j++){\n            if(del[j] !== buf[pos+j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function(chr, buf, pos){\n      const {record_delimiter} = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for(let i = 0; i < recordDelimiterLength; i++){\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if(rd[0] !== chr){\n          continue;\n        }\n        for(let j = 1; j < rdLength; j++){\n          if(rd[j] !== buf[pos+j]){\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function(buf, pos, chr){\n      const {escape} = this.options;\n      if(escape === null) return false;\n      const l = escape.length;\n      if(escape[0] === chr){\n        for(let i = 0; i < l; i++){\n          if(escape[i] !== buf[pos+i]){\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function(buf, pos){\n      const {quote} = this.options;\n      if(quote === null) return false;\n      const l = quote.length;\n      for(let i = 0; i < l; i++){\n        if(quote[i] !== buf[pos+i]){\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function(buf, pos){\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from('\\r\\n', encoding),\n        Buffer.from('\\n', encoding),\n        Buffer.from('\\r', encoding),\n      ];\n      loop: for(let i = 0; i < rds.length; i++){\n        const l = rds[i].length;\n        for(let j = 0; j < l; j++){\n          if(rds[i][j] !== buf[pos + j]){\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function(msg){\n      const {encoding, raw, skip_records_with_error} = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if(skip_records_with_error){\n        this.state.recordHasError = true;\n        if(this.options.on_skip !== undefined){\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      }else{\n        return err;\n      }\n    },\n    __infoDataSet: function(){\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function(){\n      const {columns, raw, encoding} = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function(){\n      const {columns} = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ?\n          (columns.length > this.state.record.length ?\n            columns[this.state.record.length].name :\n            null\n          ) :\n          this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    }\n  };\n};\n\n\nexport {transform, CsvError};\n", "\nimport {CsvError, transform} from './api/index.js';\n\nconst parse = function(data, opts={}){\n  if(typeof data === 'string'){\n    data = Buffer.from(data);\n  }\n  const records = opts && opts.objname ? {} : [];\n  const parser = transform(opts);\n  const push = (record) => {\n    if(parser.options.objname === undefined)\n      records.push(record);\n    else{\n      records[record[0]] = record[1];\n    }\n  };\n  const close = () => {};\n  const err1 = parser.parse(data, false, push, close);\n  if(err1 !== undefined) throw err1;\n  const err2 = parser.parse(undefined, true, push, close);\n  if(err2 !== undefined) throw err2;\n  return records;\n};\n\n// export default parse\nexport { parse };\nexport { CsvError };\n", "import { parse } from 'csv-parse/sync'\n\nconst IMPORTANCEWEIGHT = {\n\tuniqueHeaderProbalility: 1,\n\theaderTypesProbability: 5,\n\theaderFrequencyProbability: 5,\n\tdataTypesDifference: 5\n}\n\nconst getType = (value: string | number): string => {\n\tif (!value || value === '') return 'undefined'\n\tif (typeof value === 'number') return 'number'\n\tif (typeof value !== 'string') return 'string'\n\n\ttry {\n\t\t// remove special langue number formatters (e.g. 1 000 000,01)\n\t\tconst formattedValue = value\n\t\t\t.trim()\n\t\t\t.replace(/\\s/g, '')\n\t\t\t.replace(/,/g, '.')\n\t\t\t.replace(/^[\u2212\u2013\u2014]/, '-')\n\t\t\t.replace(/[\\u2012\\u2013\\u2014\\u2015]/g, '-')\n\n\t\treturn !isNaN(Number(formattedValue)) ? 'number' : 'string'\n\t} catch (e) {\n\t\treturn 'string'\n\t}\n}\n\nconst simpleParseData = (data: string, delimiter = ','): string[][] => {\n\treturn parse(data, {\n\t\tdelimiter: delimiter,\n\t\tskip_empty_lines: true,\n\t\tcolumns: false,\n\t\tcomment: '#',\n\t\trelax_column_count: true,\n\t\tskip_records_with_error: true,\n\t\ttrim: true\n\t})\n}\n\nconst percentOfUniqueItems = (clearedHeader: string[]): number => {\n\tif (clearedHeader.length === 0) return 0\n\n\tconst flattenedArr = clearedHeader.flat()\n\tconst uniqueValues = new Set(flattenedArr.filter(Boolean))\n\n\tconst totalValues = flattenedArr.length\n\tconst uniqueValueCount = uniqueValues.size\n\n\treturn (uniqueValueCount / totalValues) * 100\n}\n\nconst percentOfTypes = (rowValues: string[]): number => {\n\tconst filteredItems = rowValues.filter((element) => element && element === 'string')\n\n\tif (filteredItems.length === 0) return 0\n\n\treturn (filteredItems.length / rowValues.length) * 100\n}\n\nconst percentOfFrequency = (rowValues: string[][], items: string[]): number => {\n\tconst existsCounts = rowValues.map((rowData, rowKey) => {\n\t\tconst equalItems = rowData.filter((element) => element === items[rowKey])\n\t\treturn (equalItems.length / rowData.length) * 100\n\t})\n\n\tconst filteredItems = existsCounts.filter((item) => item > 0)\n\tconst probabilityPercent = (filteredItems.length / existsCounts.length) * 100\n\treturn 100 - probabilityPercent\n}\n\nconst percentOfDifference = (values: string[][], types: string[]): number => {\n\tlet nonMatchingCount = 0\n\n\tfor (const row of values) {\n\t\tif (types.length === row.length && types.join(',') !== row.join(',')) {\n\t\t\tnonMatchingCount++\n\t\t}\n\t}\n\treturn (nonMatchingCount / values.length) * 100\n}\n\nconst convertValuesToTypes = (\n\trowValues: string[][],\n\tmissingHeaderElements: number[]\n): string[][] => {\n\tconst filteredValues =\n\t\tmissingHeaderElements.length > 0\n\t\t\t? rowValues.map((row) => row.filter((_, index) => !missingHeaderElements.includes(index)))\n\t\t\t: rowValues\n\treturn filteredValues.map((rowData, rowKey) => {\n\t\treturn rowData.map((element, dataIndex) => {\n\t\t\tconst currentType = getType(element)\n\n\t\t\tif (currentType === 'undefined' && rowKey > 0) {\n\t\t\t\treturn getType(filteredValues[rowKey - 1][dataIndex])\n\t\t\t}\n\n\t\t\treturn currentType\n\t\t})\n\t})\n}\n\nexport const headerDetect = (data: string, delimiter = ','): number => {\n\tconst parsedData = simpleParseData(data, delimiter)\n\tif (parsedData.length < 2) return 0\n\n\tconst headers = parsedData.shift()\n\tif (!headers) return 0\n\n\tconst missingHeaderElements = []\n\tfor (let headerKey = 0; headerKey < headers.length; headerKey++) {\n\t\tconst header = headers[headerKey]\n\t\tif (!header) {\n\t\t\tmissingHeaderElements.push(headerKey)\n\t\t}\n\t}\n\tconst clearedHeader = headers.filter(\n\t\t(element: string) => element && element !== null && element !== ''\n\t)\n\n\tconst probabilites: number[] = []\n\tlet probabilitesCount = 0\n\tconst uniqueHeaderProbalility = percentOfUniqueItems(clearedHeader)\n\tprobabilites.push(uniqueHeaderProbalility * (IMPORTANCEWEIGHT.uniqueHeaderProbalility | 1))\n\tprobabilitesCount += IMPORTANCEWEIGHT.uniqueHeaderProbalility | 1\n\n\tconst headerTypes = clearedHeader.map((header) => getType(header))\n\tconst clearHeaderTypes = headerTypes.filter((header) => header !== 'undefined')\n\n\tconst headerTypesProbability = percentOfTypes(\n\t\tclearHeaderTypes.length > 0 ? clearHeaderTypes : headerTypes\n\t)\n\tprobabilites.push(headerTypesProbability * (IMPORTANCEWEIGHT.headerTypesProbability | 1))\n\tprobabilitesCount += IMPORTANCEWEIGHT.headerTypesProbability | 1\n\n\tconst transposedData = parsedData[0].map((_, colIndex) => parsedData.map((row) => row[colIndex]))\n\tconst headerFreqProbability = percentOfFrequency(transposedData, headers)\n\tprobabilites.push(headerFreqProbability * (IMPORTANCEWEIGHT.headerFrequencyProbability | 1))\n\tprobabilitesCount += IMPORTANCEWEIGHT.headerFrequencyProbability | 1\n\n\tconst dataTypes = convertValuesToTypes(parsedData, missingHeaderElements)\n\tconst dataTypesDifference = percentOfDifference(dataTypes, headerTypes)\n\tprobabilites.push(dataTypesDifference * (IMPORTANCEWEIGHT.dataTypesDifference | 1))\n\tprobabilitesCount += IMPORTANCEWEIGHT.dataTypesDifference | 1\n\n\treturn probabilites.reduce((a, b) => a + b) / probabilitesCount / 100\n}\n", "export const delimiterDetect = (data: string): string => {\n\tlet content = data\n\t// Remove all escaped characters\n\tcontent = content.replace(/\\\\./g, '')\n\t// Remove all quoted characters\n\tcontent = content.replace(/\".*?\"/gs, '0')\n\t// Remove all empty lines\n\tcontent = content.replace(/^\\s*[\\r\\n]/gm, '')\n\t// Split by new line\n\tconst lines = content.split(/[\\r\\n]/)\n\tif (lines.at(-1) === '') {\n\t\tlines.pop()\n\t}\n\n\tconst standardDelimiters = ['\\t', ';', ',', '|', '^', '~', ':', ' ', '`']\n\tconst results: { [key: string]: number } = {}\n\tconst resultByLine: { [key: string]: number[] } = {}\n\n\tlines.forEach((line) => {\n\t\tstandardDelimiters.forEach((delimiter) => {\n\t\t\tconst count = line.split(delimiter).length\n\t\t\tif (count === 1) return\n\n\t\t\tif (!results[delimiter]) {\n\t\t\t\tresults[delimiter] = 0\n\t\t\t\tresultByLine[delimiter] = []\n\t\t\t}\n\n\t\t\tresults[delimiter] += count - 1\n\t\t\tresultByLine[delimiter].push(count - 1)\n\t\t})\n\t})\n\n\tconst possibleDelimiters = Object.keys(results)\n\tif (possibleDelimiters.length === 1) {\n\t\treturn possibleDelimiters[0]\n\t}\n\n\tconst calculateMean = (values: number[]): number => {\n\t\tconst mean = values.reduce((sum, current) => sum + current) / values.length\n\t\treturn mean\n\t}\n\n\tconst calculateVariance = (values: number[]): number => {\n\t\tconst average = calculateMean(values)\n\t\tconst squareDiffs = values.map((value: number): number => {\n\t\t\tconst diff = value - average\n\t\t\treturn diff * diff\n\t\t})\n\n\t\tconst variance = calculateMean(squareDiffs)\n\t\treturn variance\n\t}\n\n\tconst calculateSD = (variance: number): number => {\n\t\treturn Math.sqrt(variance)\n\t}\n\n\tconst varianceElements = Object.keys(resultByLine)\n\t\t.map((key) => {\n\t\t\tconst line = resultByLine[key]\n\n\t\t\tconst variance = calculateVariance(line)\n\t\t\tconst sd = calculateSD(variance)\n\t\t\treturn { delimiter: key, value: sd }\n\t\t})\n\t\t.filter((sd) => sd.value < 0.1)\n\t\t.sort((element) => element.value)\n\n\tif (varianceElements.length === 1) {\n\t\treturn varianceElements[0].delimiter\n\t}\n\n\tif (varianceElements.length > 1) {\n\t\tconst variancedKeys = varianceElements.map((element) => element.delimiter)\n\t\tstandardDelimiters.forEach((delimiter) => {\n\t\t\tif (variancedKeys.includes(delimiter)) {\n\t\t\t\treturn delimiter\n\t\t\t}\n\t\t})\n\t}\n\n\treturn ','\n}\n", "import { Options, parse } from 'csv-parse/sync'\nimport { headerDetect } from './headerDetect'\nimport { delimiterDetect } from './delimiterDetect'\n\nimport { Anim, Data, Config, Styles } from 'vizzu'\nimport * as CA from 'vizzu/dist/module/canimctrl.js';\nimport * as CC from 'vizzu/dist/module/cchart'\nimport { Plugin, PluginHooks, PrepareAnimationContext } from 'vizzu/dist/plugins.js'\nimport { AnimCompleting } from 'vizzu/dist/animcompleting'\n\nexport interface optionsTypes {\n\tdelimiter?: string\n\tencoding?: BufferEncoding\n\theaders?: boolean\n\tautoheader?: boolean\n\temptyColumnPrefix?: string\n\thasHeader?: boolean\n}\nexport interface csvTypes {\n\turl?: string\n\tcontent?: string\n\toptions?: optionsTypes\n}\n\nexport interface csvTarget {\n\ttarget: {\n\t\tdata: {\n\t\t\tcsv: csvTypes\n\t\t}\n\t}\n}\n\nexport interface csvDataType extends Data.Filter {\n\tcsv: csvTypes\n}\n\nexport interface Target {\n    data?: Data.Set | csvDataType;\n    config?: Config.Chart;\n    style?: Styles.Chart | null;\n}\nexport interface Keyframe {\n    target: Target | CC.Snapshot;\n    options?: Options;\n}\nexport type Keyframes = Keyframe[];\nexport type AnimTarget = Keyframes | CA.CAnimation;\n\ndeclare module 'vizzu' {\n\texport interface Vizzu {\n\t\tanimate(target: AnimTarget, options?: Anim.ControlOptions): AnimCompleting\n\t}\n}\nexport interface dataSeries {\n\tname: string\n\tvalues: number[] | string[]\n}\nexport interface dataType {\n\tseries: dataSeries[]\n}\n\nexport class DataParser implements Plugin {\n\tprivate _data: dataType | null = null\n\tprivate _headers: string[] | null = null\n\tprivate _autoheader = true\n\tprivate _isHeader = true\n\tprivate _hasHeader = false\n\tprivate _emptyColumnPrefix = 'Column'\n\tprivate _probabilityVariable = 0.5\n\tprivate _detectedDelimiter = ','\n\n\tpublic parserOptions: Options = {\n\t\tencoding: 'utf-8'\n\t}\n\n\tmeta = {\n\t\tname: 'csvParser'\n\t}\n\n\tget hasHeader(): boolean {\n\t\treturn this._isHeader\n\t}\n\n\tget data(): dataType | null {\n\t\treturn this._data\n\t}\n\n\tget delimiter(): string {\n\t\treturn this.parserOptions.delimiter?.toString() || ','\n\t}\n\n\tget detectedDelimiter(): string {\n\t\treturn this._detectedDelimiter\n\t}\n\n\tget api() {\n\t\treturn {\n\t\t\thasHeader: this.hasHeader,\n\t\t\tdelimiter: this.delimiter,\n\t\t\tdetectedDelimiter: this.detectedDelimiter,\n\t\t\tdata: this.data\n\t\t}\n\t}\n\n\tget hooks(): PluginHooks {\n\t\tthis._headers = null\n\t\tthis._autoheader = true\n\t\tthis._isHeader = true\n\t\tthis._hasHeader = false\n\t\tthis._emptyColumnPrefix = 'Column'\n\t\tthis.parserOptions = {\n\t\t\tencoding: 'utf-8'\n\t\t}\n\n\t\treturn {\n\t\t\tprepareAnimation: Object.assign(\n\t\t\t\tasync (ctx: PrepareAnimationContext, next: () => void) => {\n\t\t\t\t\tif (!Array.isArray(ctx.target)) {\n\t\t\t\t\t\tnext()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const { target } of ctx.target) {\n\t\t\t\t\t\tif (!target || !('data' in target) || !target.data) continue\n\n\t\t\t\t\t\tif (!('csv' in target.data) || !target.data.csv) continue\n\n\t\t\t\t\t\tconst csvOptions: csvTypes = target.data.csv\n\t\t\t\t\t\tif (!('url' in csvOptions) && !('content' in csvOptions)) continue\n\n\t\t\t\t\t\tif ('options' in csvOptions && csvOptions.options) {\n\t\t\t\t\t\t\tthis._setOptions(csvOptions.options)\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst data = await this.parse(csvOptions.url || csvOptions.content || '')\n\t\t\t\t\t\t\tif (!data || !('series' in data) || !data.series) {\n\t\t\t\t\t\t\t\tthrow new Error('Invalid data')\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!this._isHeader && !this._autoheader) {\n\t\t\t\t\t\t\t\tthrow new Error('CSV file has no header')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget.data = data\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (error: unknown) {\n\t\t\t\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t\t\t\tconsole.error(error.message)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tnext()\n\t\t\t\t},\n\t\t\t\t{ priority: 0.999 }\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate _setOptions(options: optionsTypes) {\n\t\tif ('delimiter' in options && options.delimiter) {\n\t\t\tthis.parserOptions.delimiter = options.delimiter\n\t\t}\n\n\t\tif ('encoding' in options && options.encoding) {\n\t\t\tthis.parserOptions.encoding = options.encoding\n\t\t}\n\n\t\tif ('hasHeader' in options && options.hasHeader) {\n\t\t\tthis._hasHeader = options.hasHeader\n\t\t\tthis._isHeader = true\n\t\t}\n\n\t\tif ('headers' in options && options.headers && Array.isArray(options.headers)) {\n\t\t\tthis._headers = options.headers\n\t\t}\n\n\t\tif ('autoheader' in options && options.autoheader) {\n\t\t\tthis._autoheader = options.autoheader\n\t\t}\n\t\tif ('emptyColumnPrefix' in options && options.emptyColumnPrefix) {\n\t\t\tthis._emptyColumnPrefix = options.emptyColumnPrefix\n\t\t}\n\t}\n\n\tpublic convertNumbers(data: dataType): dataType {\n\t\tif (!data || !('series' in data) || !data.series) return data\n\n\t\tdata.series = data.series.map(\n\t\t\t(item: {\n\t\t\t\tname: string\n\t\t\t\tvalues: number[] | string[]\n\t\t\t}): { name: string; values: string[] | number[] } => {\n\t\t\t\tif (\n\t\t\t\t\t'values' in item &&\n\t\t\t\t\titem.values &&\n\t\t\t\t\titem.values.every((value: string | number) => !isNaN(Number(value)))\n\t\t\t\t) {\n\t\t\t\t\titem.values = item.values.map((value: string | number) => Number(value))\n\t\t\t\t}\n\t\t\t\treturn item\n\t\t\t}\n\t\t)\n\t\treturn data\n\t}\n\n\tpublic async parse(input: string, options: Options = {}, convert = true): Promise<dataType | null> {\n\t\tif (!input) return null\n\n\t\tif (options) {\n\t\t\tthis.parserOptions = { ...this.parserOptions, ...options }\n\t\t}\n\t\tawait this.setSource(input)\n\n\t\tif (!this.data) return null\n\n\t\tif (!convert) return this.data\n\n\t\treturn this.convertNumbers(this.data)\n\t}\n\n\tpublic async setSource(source: string) {\n\t\tif (source.startsWith('http')) {\n\t\t\tsource = await this.fetchData(source)\n\t\t}\n\n\t\tconst delimiter = this.getDelimiter(source)\n\t\tthis.parserOptions.delimiter = delimiter\n\n\t\tthis._isHeader = true\n\t\tif (!this._hasHeader && !Array.isArray(this._headers)) {\n\t\t\tconst headerProbability = headerDetect(source, delimiter)\n\t\t\tif (headerProbability < this._probabilityVariable) {\n\t\t\t\tconsole.error('CSV file has no header', headerProbability)\n\t\t\t\tthis._isHeader = false\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tconst parsedInput = parse(source, {\n\t\t\t\tskip_empty_lines: true,\n\t\t\t\tcomment: '#',\n\t\t\t\trelax_column_count: true,\n\t\t\t\tskip_records_with_error: true,\n\t\t\t\t...this.parserOptions\n\t\t\t})\n\t\t\tthis._data = this._buildData(parsedInput)\n\t\t} catch (error: unknown) {\n\t\t\tif (error instanceof Error) {\n\t\t\t\tconsole.error(error.message)\n\t\t\t}\n\t\t\tthis._data = null\n\t\t\treturn\n\t\t}\n\t}\n\n\tpublic async fetchData(url: string): Promise<string> {\n\t\tconst response = await fetch(url)\n\t\tif (!response.ok) {\n\t\t\tconsole.error(`Error fetching data from ${url}`)\n\t\t\treturn ''\n\t\t}\n\t\treturn await response.text()\n\t}\n\n\tpublic getDelimiter(data: string): string {\n\t\tthis._detectedDelimiter = delimiterDetect(data);\n\t\treturn this.parserOptions.delimiter?.toString() || this._detectedDelimiter\n\t}\n\n\tprivate _buildData(records: string[][]): dataType | null {\n\t\tif (records.length === 0) {\n\t\t\treturn null\n\t\t}\n\t\tconst header: string[] = Array.isArray(this._headers) ? this._headers : this._getHeader(records)\n\t\tconst series = []\n\t\tfor (let column = 0; column < records[0].length; column++) {\n\t\t\tconst headerName =\n\t\t\t\theader[column] && header[column].length > 0 ? header[column] : this._emptyColumnPrefix + (column + 1)\n\n\t\t\tseries.push({\n\t\t\t\tname: headerName.trim(),\n\t\t\t\tvalues: records.map((record) => record[column] || '')\n\t\t\t})\n\t\t}\n\t\treturn { series: series }\n\t}\n\n\tprivate _getHeader(records: string[][]): string[] {\n\t\tlet headerResponse: string[] = []\n\t\tif (this._isHeader && records.length > 0 && records[0].length > 0) {\n\t\t\theaderResponse = records.shift() ?? []\n\t\t\tif (headerResponse.length > 0) {\n\t\t\t\treturn headerResponse.map((item, key: number) =>\n\t\t\t\t\titem.length === 0 ? this._emptyColumnPrefix + (key + 1) : item\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\treturn Object.keys(records[0]).map((key) => this._emptyColumnPrefix + (parseInt(key) + 1))\n\t}\n}\n", "import { DataParser } from './dataParser'\n\nexport class CSVParser extends DataParser {}\n\nexport default CSVParser\n"],
  "mappings": "AAAA,IAAIA,GAAY,CAAC,EACbC,GAAa,GACjB,SAASC,IAAQ,CACf,GAAID,GAAY,OAAOD,GACvBC,GAAa,GACbD,GAAU,WAAaG,EACvBH,GAAU,YAAcI,EACxBJ,GAAU,cAAgBK,EAM1B,QALIC,EAAS,CAAC,EACVC,EAAY,CAAC,EACbC,EAAM,OAAO,WAAe,IAAc,WAAa,MACvDC,EAAO,mEAEFC,EAAI,EAAGC,EAAMF,EAAK,OAAQC,EAAIC,EAAK,EAAED,EAC5CJ,EAAOI,CAAC,EAAID,EAAKC,CAAC,EAClBH,EAAUE,EAAK,WAAWC,CAAC,CAAC,EAAIA,EAKlCH,EAAU,IAAI,WAAW,CAAC,CAAC,EAAI,GAC/BA,EAAU,IAAI,WAAW,CAAC,CAAC,EAAI,GAE/B,SAASK,EAAQC,EAAK,CACpB,IAAIF,EAAME,EAAI,OAEd,GAAIF,EAAM,EAAI,EACZ,MAAM,IAAI,MAAM,gDAAgD,EAKlE,IAAIG,EAAWD,EAAI,QAAQ,GAAG,EAC1BC,IAAa,KAAIA,EAAWH,GAChC,IAAII,EAAkBD,IAAaH,EAAM,EAAI,EAAIG,EAAW,EAC5D,MAAO,CAACA,EAAUC,CAAe,CACnC,CAGA,SAASZ,EAAWU,EAAK,CACvB,IAAIG,EAAOJ,EAAQC,CAAG,EAClBC,EAAWE,EAAK,CAAC,EACjBD,EAAkBC,EAAK,CAAC,EAC5B,OAAQF,EAAWC,GAAmB,EAAI,EAAIA,CAChD,CAEA,SAASE,EAAYJ,EAAKC,EAAUC,EAAiB,CACnD,OAAQD,EAAWC,GAAmB,EAAI,EAAIA,CAChD,CAEA,SAASX,EAAYS,EAAK,CACxB,IAAIK,EACAF,EAAOJ,EAAQC,CAAG,EAClBC,EAAWE,EAAK,CAAC,EACjBD,EAAkBC,EAAK,CAAC,EACxBG,EAAM,IAAIX,EAAIS,EAAYJ,EAAKC,EAAUC,CAAe,CAAC,EACzDK,EAAU,EAEVT,EAAMI,EAAkB,EAAID,EAAW,EAAIA,EAC3CJ,EAEJ,IAAKA,EAAI,EAAGA,EAAIC,EAAKD,GAAK,EACxBQ,EAAMX,EAAUM,EAAI,WAAWH,CAAC,CAAC,GAAK,GAAKH,EAAUM,EAAI,WAAWH,EAAI,CAAC,CAAC,GAAK,GAAKH,EAAUM,EAAI,WAAWH,EAAI,CAAC,CAAC,GAAK,EAAIH,EAAUM,EAAI,WAAWH,EAAI,CAAC,CAAC,EAC3JS,EAAIC,GAAS,EAAIF,GAAO,GAAK,IAC7BC,EAAIC,GAAS,EAAIF,GAAO,EAAI,IAC5BC,EAAIC,GAAS,EAAIF,EAAM,IAGzB,OAAIH,IAAoB,IACtBG,EAAMX,EAAUM,EAAI,WAAWH,CAAC,CAAC,GAAK,EAAIH,EAAUM,EAAI,WAAWH,EAAI,CAAC,CAAC,GAAK,EAC9ES,EAAIC,GAAS,EAAIF,EAAM,KAGrBH,IAAoB,IACtBG,EAAMX,EAAUM,EAAI,WAAWH,CAAC,CAAC,GAAK,GAAKH,EAAUM,EAAI,WAAWH,EAAI,CAAC,CAAC,GAAK,EAAIH,EAAUM,EAAI,WAAWH,EAAI,CAAC,CAAC,GAAK,EACvHS,EAAIC,GAAS,EAAIF,GAAO,EAAI,IAC5BC,EAAIC,GAAS,EAAIF,EAAM,KAGlBC,CACT,CAEA,SAASE,EAAgBC,EAAK,CAC5B,OAAOhB,EAAOgB,GAAO,GAAK,EAAE,EAAIhB,EAAOgB,GAAO,GAAK,EAAE,EAAIhB,EAAOgB,GAAO,EAAI,EAAE,EAAIhB,EAAOgB,EAAM,EAAE,CAClG,CAEA,SAASC,EAAYC,EAAOC,EAAOC,EAAK,CAItC,QAHIR,EACAS,EAAS,CAAC,EAELjB,EAAIe,EAAOf,EAAIgB,EAAKhB,GAAK,EAChCQ,GAAOM,EAAMd,CAAC,GAAK,GAAK,WAAac,EAAMd,EAAI,CAAC,GAAK,EAAI,QAAUc,EAAMd,EAAI,CAAC,EAAI,KAClFiB,EAAO,KAAKN,EAAgBH,CAAG,CAAC,EAGlC,OAAOS,EAAO,KAAK,EAAE,CACvB,CAEA,SAAStB,EAAcmB,EAAO,CAS5B,QARIN,EACAP,EAAMa,EAAM,OACZI,EAAajB,EAAM,EAEnBkB,EAAQ,CAAC,EACTC,EAAiB,MAGZpB,EAAI,EAAGqB,EAAOpB,EAAMiB,EAAYlB,EAAIqB,EAAMrB,GAAKoB,EACtDD,EAAM,KAAKN,EAAYC,EAAOd,EAAGA,EAAIoB,EAAiBC,EAAOA,EAAOrB,EAAIoB,CAAc,CAAC,EAIzF,OAAIF,IAAe,GACjBV,EAAMM,EAAMb,EAAM,CAAC,EACnBkB,EAAM,KAAKvB,EAAOY,GAAO,CAAC,EAAIZ,EAAOY,GAAO,EAAI,EAAE,EAAI,IAAI,GACjDU,IAAe,IACxBV,GAAOM,EAAMb,EAAM,CAAC,GAAK,GAAKa,EAAMb,EAAM,CAAC,EAC3CkB,EAAM,KAAKvB,EAAOY,GAAO,EAAE,EAAIZ,EAAOY,GAAO,EAAI,EAAE,EAAIZ,EAAOY,GAAO,EAAI,EAAE,EAAI,GAAG,GAG7EW,EAAM,KAAK,EAAE,CACtB,CAEA,OAAO7B,EACT,CAEA,IAAIgC,GAAY,CAAC,EACbC,GAAa,GACjB,SAASC,IAAQ,CACf,GAAID,GAAY,OAAOD,GACvBC,GAAa,GAGb,OAAAD,GAAU,KAAO,SAAUG,EAAQC,EAAQC,EAAMC,EAAMC,EAAQ,CAC7D,IAAIC,EAAGC,EACHC,EAAOH,EAAS,EAAID,EAAO,EAC3BK,GAAQ,GAAKD,GAAQ,EACrBE,EAAQD,GAAQ,EAChBE,EAAQ,GACRnC,EAAI2B,EAAOE,EAAS,EAAI,EACxBO,EAAIT,EAAO,GAAK,EAChBU,EAAIZ,EAAOC,EAAS1B,CAAC,EAMzB,IALAA,GAAKoC,EACLN,EAAIO,GAAK,GAAK,CAACF,GAAS,EACxBE,IAAM,CAACF,EACPA,GAASH,EAEFG,EAAQ,EAAGL,EAAIA,EAAI,IAAML,EAAOC,EAAS1B,CAAC,EAAGA,GAAKoC,EAAGD,GAAS,EAAG,CAMxE,IAJAJ,EAAID,GAAK,GAAK,CAACK,GAAS,EACxBL,IAAM,CAACK,EACPA,GAASP,EAEFO,EAAQ,EAAGJ,EAAIA,EAAI,IAAMN,EAAOC,EAAS1B,CAAC,EAAGA,GAAKoC,EAAGD,GAAS,EAAG,CAExE,GAAIL,IAAM,EACRA,EAAI,EAAII,MACH,IAAIJ,IAAMG,EACf,OAAOF,EAAI,KAAOM,EAAI,GAAK,GAAK,MAEhCN,EAAIA,EAAI,KAAK,IAAI,EAAGH,CAAI,EACxBE,EAAIA,EAAII,EAGV,OAAQG,EAAI,GAAK,GAAKN,EAAI,KAAK,IAAI,EAAGD,EAAIF,CAAI,CAChD,EAEAN,GAAU,MAAQ,SAAUG,EAAQa,EAAOZ,EAAQC,EAAMC,EAAMC,EAAQ,CACrE,IAAIC,EAAGC,EAAGQ,EACNP,EAAOH,EAAS,EAAID,EAAO,EAC3BK,GAAQ,GAAKD,GAAQ,EACrBE,EAAQD,GAAQ,EAChBO,EAAKZ,IAAS,GAAK,KAAK,IAAI,EAAG,GAAG,EAAI,KAAK,IAAI,EAAG,GAAG,EAAI,EACzD5B,EAAI2B,EAAO,EAAIE,EAAS,EACxBO,EAAIT,EAAO,EAAI,GACfU,EAAIC,EAAQ,GAAKA,IAAU,GAAK,EAAIA,EAAQ,EAAI,EAAI,EAqCxD,IApCAA,EAAQ,KAAK,IAAIA,CAAK,EAElB,MAAMA,CAAK,GAAKA,IAAU,KAC5BP,EAAI,MAAMO,CAAK,EAAI,EAAI,EACvBR,EAAIG,IAEJH,EAAI,KAAK,MAAM,KAAK,IAAIQ,CAAK,EAAI,KAAK,GAAG,EAErCA,GAASC,EAAI,KAAK,IAAI,EAAG,CAACT,CAAC,GAAK,IAClCA,IACAS,GAAK,GAGHT,EAAII,GAAS,EACfI,GAASE,EAAKD,EAEdD,GAASE,EAAK,KAAK,IAAI,EAAG,EAAIN,CAAK,EAGjCI,EAAQC,GAAK,IACfT,IACAS,GAAK,GAGHT,EAAII,GAASD,GACfF,EAAI,EACJD,EAAIG,GACKH,EAAII,GAAS,GACtBH,GAAKO,EAAQC,EAAI,GAAK,KAAK,IAAI,EAAGX,CAAI,EACtCE,EAAIA,EAAII,IAERH,EAAIO,EAAQ,KAAK,IAAI,EAAGJ,EAAQ,CAAC,EAAI,KAAK,IAAI,EAAGN,CAAI,EACrDE,EAAI,IAIDF,GAAQ,EAAGH,EAAOC,EAAS1B,CAAC,EAAI+B,EAAI,IAAK/B,GAAKoC,EAAGL,GAAK,IAAKH,GAAQ,EAAG,CAK7E,IAHAE,EAAIA,GAAKF,EAAOG,EAChBC,GAAQJ,EAEDI,EAAO,EAAGP,EAAOC,EAAS1B,CAAC,EAAI8B,EAAI,IAAK9B,GAAKoC,EAAGN,GAAK,IAAKE,GAAQ,EAAG,CAE5EP,EAAOC,EAAS1B,EAAIoC,CAAC,GAAKC,EAAI,GAChC,EAEOf,EACT,CAEA,IAAImB,EAAY,CAAC,EACbC,GAAW,GACf,SAASC,IAAM,CACb,GAAID,GAAU,OAAOD,EACrBC,GAAW,GAEX,IAAME,EAASpD,GAAM,EAEfqD,EAAUrB,GAAM,EAEhBsB,EAAsB,OAAO,QAAW,YAAc,OAAO,OAAO,KAAW,WAAa,OAAO,IAAO,4BAA4B,EAC1I,KACFL,EAAU,OAASM,EACnBN,EAAU,WAAaO,EACvBP,EAAU,kBAAoB,GAC9B,IAAMQ,EAAe,WACrBR,EAAU,WAAaQ,EAgBvBF,EAAO,oBAAsBG,EAAkB,EAE3C,CAACH,EAAO,qBAAuB,OAAO,QAAY,KAAe,OAAO,QAAQ,OAAU,YAC5F,QAAQ,MAAM,+IAAoJ,EAGpK,SAASG,GAAoB,CAE3B,GAAI,CACF,IAAMzC,EAAM,IAAI,WAAW,CAAC,EACtB0C,EAAQ,CACZ,IAAK,UAAY,CACf,MAAO,GACT,CACF,EACA,cAAO,eAAeA,EAAO,WAAW,SAAS,EACjD,OAAO,eAAe1C,EAAK0C,CAAK,EACzB1C,EAAI,IAAI,IAAM,EACvB,MAAY,CACV,MAAO,EACT,CACF,CAEA,OAAO,eAAesC,EAAO,UAAW,SAAU,CAChD,WAAY,GACZ,IAAK,UAAY,CACf,GAAKA,EAAO,SAAS,IAAI,EACzB,OAAO,KAAK,MACd,CACF,CAAC,EACD,OAAO,eAAeA,EAAO,UAAW,SAAU,CAChD,WAAY,GACZ,IAAK,UAAY,CACf,GAAKA,EAAO,SAAS,IAAI,EACzB,OAAO,KAAK,UACd,CACF,CAAC,EAED,SAASK,EAAaC,EAAQ,CAC5B,GAAIA,EAASJ,EACX,MAAM,IAAI,WAAW,cAAiBI,EAAS,gCAAmC,EAIpF,IAAMC,EAAM,IAAI,WAAWD,CAAM,EACjC,cAAO,eAAeC,EAAKP,EAAO,SAAS,EACpCO,CACT,CAYA,SAASP,EAAOQ,EAAKC,EAAkBH,EAAQ,CAE7C,GAAI,OAAOE,GAAQ,SAAU,CAC3B,GAAI,OAAOC,GAAqB,SAC9B,MAAM,IAAI,UAAU,oEAAsE,EAG5F,OAAOC,EAAYF,CAAG,CACxB,CAEA,OAAOG,EAAKH,EAAKC,EAAkBH,CAAM,CAC3C,CAEAN,EAAO,SAAW,KAElB,SAASW,EAAKpB,EAAOkB,EAAkBH,EAAQ,CAC7C,GAAI,OAAOf,GAAU,SACnB,OAAOqB,EAAWrB,EAAOkB,CAAgB,EAG3C,GAAI,YAAY,OAAOlB,CAAK,EAC1B,OAAOsB,EAActB,CAAK,EAG5B,GAAIA,GAAS,KACX,MAAM,IAAI,UAAU,kHAAyH,OAAOA,CAAK,EAO3J,GAJIuB,EAAWvB,EAAO,WAAW,GAAKA,GAASuB,EAAWvB,EAAM,OAAQ,WAAW,GAI/E,OAAO,kBAAsB,MAAgBuB,EAAWvB,EAAO,iBAAiB,GAAKA,GAASuB,EAAWvB,EAAM,OAAQ,iBAAiB,GAC1I,OAAOwB,EAAgBxB,EAAOkB,EAAkBH,CAAM,EAGxD,GAAI,OAAOf,GAAU,SACnB,MAAM,IAAI,UAAU,uEAAyE,EAG/F,IAAMyB,EAAUzB,EAAM,SAAWA,EAAM,QAAQ,EAE/C,GAAIyB,GAAW,MAAQA,IAAYzB,EACjC,OAAOS,EAAO,KAAKgB,EAASP,EAAkBH,CAAM,EAGtD,IAAMW,EAAIC,EAAW3B,CAAK,EAC1B,GAAI0B,EAAG,OAAOA,EAEd,GAAI,OAAO,OAAW,KAAe,OAAO,aAAe,MAAQ,OAAO1B,EAAM,OAAO,WAAW,GAAM,WACtG,OAAOS,EAAO,KAAKT,EAAM,OAAO,WAAW,EAAE,QAAQ,EAAGkB,EAAkBH,CAAM,EAGlF,MAAM,IAAI,UAAU,kHAAyH,OAAOf,CAAK,CAC3J,CAWAS,EAAO,KAAO,SAAUT,EAAOkB,EAAkBH,EAAQ,CACvD,OAAOK,EAAKpB,EAAOkB,EAAkBH,CAAM,CAC7C,EAIA,OAAO,eAAeN,EAAO,UAAW,WAAW,SAAS,EAC5D,OAAO,eAAeA,EAAQ,UAAU,EAExC,SAASmB,EAAWC,EAAM,CACxB,GAAI,OAAOA,GAAS,SAClB,MAAM,IAAI,UAAU,wCAA0C,EACzD,GAAIA,EAAO,EAChB,MAAM,IAAI,WAAW,cAAiBA,EAAO,gCAAmC,CAEpF,CAEA,SAASC,EAAMD,EAAME,EAAMC,EAAU,CAGnC,OAFAJ,EAAWC,CAAI,EAEXA,GAAQ,EACHf,EAAae,CAAI,EAGtBE,IAAS,OAIJ,OAAOC,GAAa,SAAWlB,EAAae,CAAI,EAAE,KAAKE,EAAMC,CAAQ,EAAIlB,EAAae,CAAI,EAAE,KAAKE,CAAI,EAGvGjB,EAAae,CAAI,CAC1B,CAOApB,EAAO,MAAQ,SAAUoB,EAAME,EAAMC,EAAU,CAC7C,OAAOF,EAAMD,EAAME,EAAMC,CAAQ,CACnC,EAEA,SAASb,EAAYU,EAAM,CACzB,OAAAD,EAAWC,CAAI,EACRf,EAAae,EAAO,EAAI,EAAII,EAAQJ,CAAI,EAAI,CAAC,CACtD,CAMApB,EAAO,YAAc,SAAUoB,EAAM,CACnC,OAAOV,EAAYU,CAAI,CACzB,EAMApB,EAAO,gBAAkB,SAAUoB,EAAM,CACvC,OAAOV,EAAYU,CAAI,CACzB,EAEA,SAASR,EAAWa,EAAQF,EAAU,CAKpC,IAJI,OAAOA,GAAa,UAAYA,IAAa,MAC/CA,EAAW,QAGT,CAACvB,EAAO,WAAWuB,CAAQ,EAC7B,MAAM,IAAI,UAAU,qBAAuBA,CAAQ,EAGrD,IAAMjB,EAAS5D,EAAW+E,EAAQF,CAAQ,EAAI,EAC1ChB,EAAMF,EAAaC,CAAM,EACvBoB,EAASnB,EAAI,MAAMkB,EAAQF,CAAQ,EAEzC,OAAIG,IAAWpB,IAIbC,EAAMA,EAAI,MAAM,EAAGmB,CAAM,GAGpBnB,CACT,CAEA,SAASoB,EAAcC,EAAO,CAC5B,IAAMtB,EAASsB,EAAM,OAAS,EAAI,EAAIJ,EAAQI,EAAM,MAAM,EAAI,EACxDrB,EAAMF,EAAaC,CAAM,EAE/B,QAASrD,EAAI,EAAGA,EAAIqD,EAAQrD,GAAK,EAC/BsD,EAAItD,CAAC,EAAI2E,EAAM3E,CAAC,EAAI,IAGtB,OAAOsD,CACT,CAEA,SAASM,EAAcgB,EAAW,CAChC,GAAIf,EAAWe,EAAW,UAAU,EAAG,CACrC,IAAMC,EAAO,IAAI,WAAWD,CAAS,EACrC,OAAOd,EAAgBe,EAAK,OAAQA,EAAK,WAAYA,EAAK,UAAU,CACtE,CAEA,OAAOH,EAAcE,CAAS,CAChC,CAEA,SAASd,EAAgBa,EAAOG,EAAYzB,EAAQ,CAClD,GAAIyB,EAAa,GAAKH,EAAM,WAAaG,EACvC,MAAM,IAAI,WAAW,sCAAwC,EAG/D,GAAIH,EAAM,WAAaG,GAAczB,GAAU,GAC7C,MAAM,IAAI,WAAW,sCAAwC,EAG/D,IAAIC,EAEJ,OAAIwB,IAAe,QAAazB,IAAW,OACzCC,EAAM,IAAI,WAAWqB,CAAK,EACjBtB,IAAW,OACpBC,EAAM,IAAI,WAAWqB,EAAOG,CAAU,EAEtCxB,EAAM,IAAI,WAAWqB,EAAOG,EAAYzB,CAAM,EAIhD,OAAO,eAAeC,EAAKP,EAAO,SAAS,EACpCO,CACT,CAEA,SAASW,EAAWc,EAAK,CACvB,GAAIhC,EAAO,SAASgC,CAAG,EAAG,CACxB,IAAM9E,EAAMsE,EAAQQ,EAAI,MAAM,EAAI,EAC5BzB,EAAMF,EAAanD,CAAG,EAE5B,OAAIqD,EAAI,SAAW,GAInByB,EAAI,KAAKzB,EAAK,EAAG,EAAGrD,CAAG,EAChBqD,CACT,CAEA,GAAIyB,EAAI,SAAW,OACjB,OAAI,OAAOA,EAAI,QAAW,UAAYC,GAAYD,EAAI,MAAM,EACnD3B,EAAa,CAAC,EAGhBsB,EAAcK,CAAG,EAG1B,GAAIA,EAAI,OAAS,UAAY,MAAM,QAAQA,EAAI,IAAI,EACjD,OAAOL,EAAcK,EAAI,IAAI,CAEjC,CAEA,SAASR,EAAQlB,EAAQ,CAGvB,GAAIA,GAAUJ,EACZ,MAAM,IAAI,WAAW,0DAAiEA,EAAa,SAAS,EAAE,EAAI,QAAQ,EAG5H,OAAOI,EAAS,CAClB,CAEA,SAASL,EAAWK,EAAQ,CAC1B,MAAI,CAACA,GAAUA,IAEbA,EAAS,GAGJN,EAAO,MAAM,CAACM,CAAM,CAC7B,CAEAN,EAAO,SAAW,SAAkBiB,EAAG,CACrC,OAAOA,GAAK,MAAQA,EAAE,YAAc,IAAQA,IAAMjB,EAAO,SAC3D,EAEAA,EAAO,QAAU,SAAiBkC,EAAGjB,EAAG,CAItC,GAHIH,EAAWoB,EAAG,UAAU,IAAGA,EAAIlC,EAAO,KAAKkC,EAAGA,EAAE,OAAQA,EAAE,UAAU,GACpEpB,EAAWG,EAAG,UAAU,IAAGA,EAAIjB,EAAO,KAAKiB,EAAGA,EAAE,OAAQA,EAAE,UAAU,GAEpE,CAACjB,EAAO,SAASkC,CAAC,GAAK,CAAClC,EAAO,SAASiB,CAAC,EAC3C,MAAM,IAAI,UAAU,uEAA2E,EAGjG,GAAIiB,IAAMjB,EAAG,MAAO,GACpB,IAAIkB,EAAID,EAAE,OACNE,EAAInB,EAAE,OAEV,QAAShE,EAAI,EAAGC,EAAM,KAAK,IAAIiF,EAAGC,CAAC,EAAGnF,EAAIC,EAAK,EAAED,EAC/C,GAAIiF,EAAEjF,CAAC,IAAMgE,EAAEhE,CAAC,EAAG,CACjBkF,EAAID,EAAEjF,CAAC,EACPmF,EAAInB,EAAEhE,CAAC,EACP,KACF,CAGF,OAAIkF,EAAIC,EAAU,GACdA,EAAID,EAAU,EACX,CACT,EAEAnC,EAAO,WAAa,SAAoBuB,EAAU,CAChD,OAAQ,OAAOA,CAAQ,EAAE,YAAY,EAAG,CACtC,IAAK,MACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,MAAO,GAET,QACE,MAAO,EACX,CACF,EAEAvB,EAAO,OAAS,SAAgBqC,EAAM/B,EAAQ,CAC5C,GAAI,CAAC,MAAM,QAAQ+B,CAAI,EACrB,MAAM,IAAI,UAAU,6CAA+C,EAGrE,GAAIA,EAAK,SAAW,EAClB,OAAOrC,EAAO,MAAM,CAAC,EAGvB,IAAI/C,EAEJ,GAAIqD,IAAW,OAGb,IAFAA,EAAS,EAEJrD,EAAI,EAAGA,EAAIoF,EAAK,OAAQ,EAAEpF,EAC7BqD,GAAU+B,EAAKpF,CAAC,EAAE,OAItB,IAAMyB,EAASsB,EAAO,YAAYM,CAAM,EACpCgC,EAAM,EAEV,IAAKrF,EAAI,EAAGA,EAAIoF,EAAK,OAAQ,EAAEpF,EAAG,CAChC,IAAIsD,EAAM8B,EAAKpF,CAAC,EAEhB,GAAI6D,EAAWP,EAAK,UAAU,EACxB+B,EAAM/B,EAAI,OAAS7B,EAAO,QACvBsB,EAAO,SAASO,CAAG,IAAGA,EAAMP,EAAO,KAAKO,CAAG,GAChDA,EAAI,KAAK7B,EAAQ4D,CAAG,GAEpB,WAAW,UAAU,IAAI,KAAK5D,EAAQ6B,EAAK+B,CAAG,UAEtCtC,EAAO,SAASO,CAAG,EAG7BA,EAAI,KAAK7B,EAAQ4D,CAAG,MAFpB,OAAM,IAAI,UAAU,6CAA+C,EAKrEA,GAAO/B,EAAI,MACb,CAEA,OAAO7B,CACT,EAEA,SAAShC,EAAW+E,EAAQF,EAAU,CACpC,GAAIvB,EAAO,SAASyB,CAAM,EACxB,OAAOA,EAAO,OAGhB,GAAI,YAAY,OAAOA,CAAM,GAAKX,EAAWW,EAAQ,WAAW,EAC9D,OAAOA,EAAO,WAGhB,GAAI,OAAOA,GAAW,SACpB,MAAM,IAAI,UAAU,2FAAoG,OAAOA,CAAM,EAGvI,IAAMvE,EAAMuE,EAAO,OACbc,EAAY,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,GAC3D,GAAI,CAACA,GAAarF,IAAQ,EAAG,MAAO,GAEpC,IAAIsF,EAAc,GAElB,OACE,OAAQjB,EAAU,CAChB,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAOrE,EAET,IAAK,OACL,IAAK,QACH,OAAOuF,GAAYhB,CAAM,EAAE,OAE7B,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOvE,EAAM,EAEf,IAAK,MACH,OAAOA,IAAQ,EAEjB,IAAK,SACH,OAAOwF,GAAcjB,CAAM,EAAE,OAE/B,QACE,GAAIe,EACF,OAAOD,EAAY,GAAKE,GAAYhB,CAAM,EAAE,OAG9CF,GAAY,GAAKA,GAAU,YAAY,EACvCiB,EAAc,EAClB,CAEJ,CAEAxC,EAAO,WAAatD,EAEpB,SAASiG,EAAapB,EAAUvD,EAAOC,EAAK,CAC1C,IAAIuE,EAAc,GA6BlB,IAtBIxE,IAAU,QAAaA,EAAQ,KACjCA,EAAQ,GAKNA,EAAQ,KAAK,UAIbC,IAAQ,QAAaA,EAAM,KAAK,UAClCA,EAAM,KAAK,QAGTA,GAAO,KAKXA,KAAS,EACTD,KAAW,EAEPC,GAAOD,GACT,MAAO,GAKT,IAFKuD,IAAUA,EAAW,UAGxB,OAAQA,EAAU,CAChB,IAAK,MACH,OAAOqB,EAAS,KAAM5E,EAAOC,CAAG,EAElC,IAAK,OACL,IAAK,QACH,OAAO4E,EAAU,KAAM7E,EAAOC,CAAG,EAEnC,IAAK,QACH,OAAO6E,GAAW,KAAM9E,EAAOC,CAAG,EAEpC,IAAK,SACL,IAAK,SACH,OAAO8E,EAAY,KAAM/E,EAAOC,CAAG,EAErC,IAAK,SACH,OAAO+E,GAAY,KAAMhF,EAAOC,CAAG,EAErC,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOgF,EAAa,KAAMjF,EAAOC,CAAG,EAEtC,QACE,GAAIuE,EAAa,MAAM,IAAI,UAAU,qBAAuBjB,CAAQ,EACpEA,GAAYA,EAAW,IAAI,YAAY,EACvCiB,EAAc,EAClB,CAEJ,CAQAxC,EAAO,UAAU,UAAY,GAE7B,SAASkD,EAAKjC,EAAGkC,EAAGnE,EAAG,CACrB,IAAM/B,EAAIgE,EAAEkC,CAAC,EACblC,EAAEkC,CAAC,EAAIlC,EAAEjC,CAAC,EACViC,EAAEjC,CAAC,EAAI/B,CACT,CAEA+C,EAAO,UAAU,OAAS,UAAkB,CAC1C,IAAM9C,EAAM,KAAK,OAEjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAGlE,QAASD,EAAI,EAAGA,EAAIC,EAAKD,GAAK,EAC5BiG,EAAK,KAAMjG,EAAGA,EAAI,CAAC,EAGrB,OAAO,IACT,EAEA+C,EAAO,UAAU,OAAS,UAAkB,CAC1C,IAAM9C,EAAM,KAAK,OAEjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAGlE,QAASD,EAAI,EAAGA,EAAIC,EAAKD,GAAK,EAC5BiG,EAAK,KAAMjG,EAAGA,EAAI,CAAC,EACnBiG,EAAK,KAAMjG,EAAI,EAAGA,EAAI,CAAC,EAGzB,OAAO,IACT,EAEA+C,EAAO,UAAU,OAAS,UAAkB,CAC1C,IAAM9C,EAAM,KAAK,OAEjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAGlE,QAASD,EAAI,EAAGA,EAAIC,EAAKD,GAAK,EAC5BiG,EAAK,KAAMjG,EAAGA,EAAI,CAAC,EACnBiG,EAAK,KAAMjG,EAAI,EAAGA,EAAI,CAAC,EACvBiG,EAAK,KAAMjG,EAAI,EAAGA,EAAI,CAAC,EACvBiG,EAAK,KAAMjG,EAAI,EAAGA,EAAI,CAAC,EAGzB,OAAO,IACT,EAEA+C,EAAO,UAAU,SAAW,UAAoB,CAC9C,IAAMM,EAAS,KAAK,OACpB,OAAIA,IAAW,EAAU,GACrB,UAAU,SAAW,EAAUuC,EAAU,KAAM,EAAGvC,CAAM,EACrDqC,EAAa,MAAM,KAAM,SAAS,CAC3C,EAEA3C,EAAO,UAAU,eAAiBA,EAAO,UAAU,SAEnDA,EAAO,UAAU,OAAS,SAAgBiB,EAAG,CAC3C,GAAI,CAACjB,EAAO,SAASiB,CAAC,EAAG,MAAM,IAAI,UAAU,2BAA2B,EACxE,OAAI,OAASA,EAAU,GAChBjB,EAAO,QAAQ,KAAMiB,CAAC,IAAM,CACrC,EAEAjB,EAAO,UAAU,QAAU,UAAmB,CAC5C,IAAIoD,EAAM,GACJC,EAAM3D,EAAU,kBACtB,OAAA0D,EAAM,KAAK,SAAS,MAAO,EAAGC,CAAG,EAAE,QAAQ,UAAW,KAAK,EAAE,KAAK,EAC9D,KAAK,OAASA,IAAKD,GAAO,SACvB,WAAaA,EAAM,GAC5B,EAEIrD,IACFC,EAAO,UAAUD,CAAmB,EAAIC,EAAO,UAAU,SAG3DA,EAAO,UAAU,QAAU,SAAiBsD,EAAQtF,EAAOC,EAAKsF,EAAWC,EAAS,CAKlF,GAJI1C,EAAWwC,EAAQ,UAAU,IAC/BA,EAAStD,EAAO,KAAKsD,EAAQA,EAAO,OAAQA,EAAO,UAAU,GAG3D,CAACtD,EAAO,SAASsD,CAAM,EACzB,MAAM,IAAI,UAAU,iFAA0F,OAAOA,CAAM,EAmB7H,GAhBItF,IAAU,SACZA,EAAQ,GAGNC,IAAQ,SACVA,EAAMqF,EAASA,EAAO,OAAS,GAG7BC,IAAc,SAChBA,EAAY,GAGVC,IAAY,SACdA,EAAU,KAAK,QAGbxF,EAAQ,GAAKC,EAAMqF,EAAO,QAAUC,EAAY,GAAKC,EAAU,KAAK,OACtE,MAAM,IAAI,WAAW,oBAAoB,EAG3C,GAAID,GAAaC,GAAWxF,GAASC,EACnC,MAAO,GAGT,GAAIsF,GAAaC,EACf,MAAO,GAGT,GAAIxF,GAASC,EACX,MAAO,GAOT,GAJAD,KAAW,EACXC,KAAS,EACTsF,KAAe,EACfC,KAAa,EACT,OAASF,EAAQ,MAAO,GAC5B,IAAInB,EAAIqB,EAAUD,EACdnB,EAAInE,EAAMD,EACRd,EAAM,KAAK,IAAIiF,EAAGC,CAAC,EACnBqB,EAAW,KAAK,MAAMF,EAAWC,CAAO,EACxCE,EAAaJ,EAAO,MAAMtF,EAAOC,CAAG,EAE1C,QAAShB,EAAI,EAAGA,EAAIC,EAAK,EAAED,EACzB,GAAIwG,EAASxG,CAAC,IAAMyG,EAAWzG,CAAC,EAAG,CACjCkF,EAAIsB,EAASxG,CAAC,EACdmF,EAAIsB,EAAWzG,CAAC,EAChB,KACF,CAGF,OAAIkF,EAAIC,EAAU,GACdA,EAAID,EAAU,EACX,CACT,EAWA,SAASwB,EAAqBjF,EAAQkF,EAAK7B,EAAYR,EAAUsC,EAAK,CAEpE,GAAInF,EAAO,SAAW,EAAG,MAAO,GAqBhC,GAnBI,OAAOqD,GAAe,UACxBR,EAAWQ,EACXA,EAAa,GACJA,EAAa,WACtBA,EAAa,WACJA,EAAa,cACtBA,EAAa,aAGfA,EAAa,CAACA,EAEVE,GAAYF,CAAU,IAExBA,EAAa8B,EAAM,EAAInF,EAAO,OAAS,GAIrCqD,EAAa,IAAGA,EAAarD,EAAO,OAASqD,GAE7CA,GAAcrD,EAAO,OAAQ,CAC/B,GAAImF,EAAK,MAAO,GAAQ9B,EAAarD,EAAO,OAAS,CACvD,SAAWqD,EAAa,EACtB,GAAI8B,EAAK9B,EAAa,MAAO,OAAO,GAStC,GALI,OAAO6B,GAAQ,WACjBA,EAAM5D,EAAO,KAAK4D,EAAKrC,CAAQ,GAI7BvB,EAAO,SAAS4D,CAAG,EAErB,OAAIA,EAAI,SAAW,EACV,GAGFE,EAAapF,EAAQkF,EAAK7B,EAAYR,EAAUsC,CAAG,EACrD,GAAI,OAAOD,GAAQ,SAGxB,OAFAA,EAAMA,EAAM,IAER,OAAO,WAAW,UAAU,SAAY,WACtCC,EACK,WAAW,UAAU,QAAQ,KAAKnF,EAAQkF,EAAK7B,CAAU,EAEzD,WAAW,UAAU,YAAY,KAAKrD,EAAQkF,EAAK7B,CAAU,EAIjE+B,EAAapF,EAAQ,CAACkF,CAAG,EAAG7B,EAAYR,EAAUsC,CAAG,EAG9D,MAAM,IAAI,UAAU,sCAAsC,CAC5D,CAEA,SAASC,EAAapG,EAAKkG,EAAK7B,EAAYR,EAAUsC,EAAK,CACzD,IAAIE,EAAY,EACZC,EAAYtG,EAAI,OAChBuG,EAAYL,EAAI,OAEpB,GAAIrC,IAAa,SACfA,EAAW,OAAOA,CAAQ,EAAE,YAAY,EAEpCA,IAAa,QAAUA,IAAa,SAAWA,IAAa,WAAaA,IAAa,YAAY,CACpG,GAAI7D,EAAI,OAAS,GAAKkG,EAAI,OAAS,EACjC,MAAO,GAGTG,EAAY,EACZC,GAAa,EACbC,GAAa,EACblC,GAAc,CAChB,CAGF,SAASmC,EAAK3D,EAAKtD,EAAG,CACpB,OAAI8G,IAAc,EACTxD,EAAItD,CAAC,EAELsD,EAAI,aAAatD,EAAI8G,CAAS,CAEzC,CAEA,IAAI9G,EAEJ,GAAI4G,EAAK,CACP,IAAIM,EAAa,GAEjB,IAAKlH,EAAI8E,EAAY9E,EAAI+G,EAAW/G,IAClC,GAAIiH,EAAKxG,EAAKT,CAAC,IAAMiH,EAAKN,EAAKO,IAAe,GAAK,EAAIlH,EAAIkH,CAAU,GAEnE,GADIA,IAAe,KAAIA,EAAalH,GAChCA,EAAIkH,EAAa,IAAMF,EAAW,OAAOE,EAAaJ,OAEtDI,IAAe,KAAIlH,GAAKA,EAAIkH,GAChCA,EAAa,EAGnB,KAGE,KAFIpC,EAAakC,EAAYD,IAAWjC,EAAaiC,EAAYC,GAE5DhH,EAAI8E,EAAY9E,GAAK,EAAGA,IAAK,CAChC,IAAImH,EAAQ,GAEZ,QAASC,EAAI,EAAGA,EAAIJ,EAAWI,IAC7B,GAAIH,EAAKxG,EAAKT,EAAIoH,CAAC,IAAMH,EAAKN,EAAKS,CAAC,EAAG,CACrCD,EAAQ,GACR,KACF,CAGF,GAAIA,EAAO,OAAOnH,CACpB,CAGF,MAAO,EACT,CAEA+C,EAAO,UAAU,SAAW,SAAkB4D,EAAK7B,EAAYR,EAAU,CACvE,OAAO,KAAK,QAAQqC,EAAK7B,EAAYR,CAAQ,IAAM,EACrD,EAEAvB,EAAO,UAAU,QAAU,SAAiB4D,EAAK7B,EAAYR,EAAU,CACrE,OAAOoC,EAAqB,KAAMC,EAAK7B,EAAYR,EAAU,EAAI,CACnE,EAEAvB,EAAO,UAAU,YAAc,SAAqB4D,EAAK7B,EAAYR,EAAU,CAC7E,OAAOoC,EAAqB,KAAMC,EAAK7B,EAAYR,EAAU,EAAK,CACpE,EAEA,SAAS+C,GAAS/D,EAAKkB,EAAQ9C,EAAQ2B,EAAQ,CAC7C3B,EAAS,OAAOA,CAAM,GAAK,EAC3B,IAAM4F,EAAYhE,EAAI,OAAS5B,EAE1B2B,GAGHA,EAAS,OAAOA,CAAM,EAElBA,EAASiE,IACXjE,EAASiE,IALXjE,EAASiE,EASX,IAAMC,EAAS/C,EAAO,OAElBnB,EAASkE,EAAS,IACpBlE,EAASkE,EAAS,GAGpB,IAAIvH,EAEJ,IAAKA,EAAI,EAAGA,EAAIqD,EAAQ,EAAErD,EAAG,CAC3B,IAAMwH,EAAS,SAAShD,EAAO,OAAOxE,EAAI,EAAG,CAAC,EAAG,EAAE,EACnD,GAAIgF,GAAYwC,CAAM,EAAG,OAAOxH,EAChCsD,EAAI5B,EAAS1B,CAAC,EAAIwH,CACpB,CAEA,OAAOxH,CACT,CAEA,SAASyH,GAAUnE,EAAKkB,EAAQ9C,EAAQ2B,EAAQ,CAC9C,OAAOqE,GAAWlC,GAAYhB,EAAQlB,EAAI,OAAS5B,CAAM,EAAG4B,EAAK5B,EAAQ2B,CAAM,CACjF,CAEA,SAASsE,GAAWrE,EAAKkB,EAAQ9C,EAAQ2B,EAAQ,CAC/C,OAAOqE,GAAWE,GAAapD,CAAM,EAAGlB,EAAK5B,EAAQ2B,CAAM,CAC7D,CAEA,SAASwE,GAAYvE,EAAKkB,EAAQ9C,EAAQ2B,EAAQ,CAChD,OAAOqE,GAAWjC,GAAcjB,CAAM,EAAGlB,EAAK5B,EAAQ2B,CAAM,CAC9D,CAEA,SAASyE,EAAUxE,EAAKkB,EAAQ9C,EAAQ2B,EAAQ,CAC9C,OAAOqE,GAAWK,GAAevD,EAAQlB,EAAI,OAAS5B,CAAM,EAAG4B,EAAK5B,EAAQ2B,CAAM,CACpF,CAEAN,EAAO,UAAU,MAAQ,SAAeyB,EAAQ9C,EAAQ2B,EAAQiB,EAAU,CAExE,GAAI5C,IAAW,OACb4C,EAAW,OACXjB,EAAS,KAAK,OACd3B,EAAS,UACA2B,IAAW,QAAa,OAAO3B,GAAW,SACnD4C,EAAW5C,EACX2B,EAAS,KAAK,OACd3B,EAAS,UACA,SAASA,CAAM,EACxBA,EAASA,IAAW,EAEhB,SAAS2B,CAAM,GACjBA,EAASA,IAAW,EAChBiB,IAAa,SAAWA,EAAW,UAEvCA,EAAWjB,EACXA,EAAS,YAGX,OAAM,IAAI,MAAM,yEAAyE,EAG3F,IAAMiE,EAAY,KAAK,OAAS5F,EAGhC,IAFI2B,IAAW,QAAaA,EAASiE,KAAWjE,EAASiE,GAErD9C,EAAO,OAAS,IAAMnB,EAAS,GAAK3B,EAAS,IAAMA,EAAS,KAAK,OACnE,MAAM,IAAI,WAAW,wCAAwC,EAG1D4C,IAAUA,EAAW,QAC1B,IAAIiB,EAAc,GAElB,OACE,OAAQjB,EAAU,CAChB,IAAK,MACH,OAAO+C,GAAS,KAAM7C,EAAQ9C,EAAQ2B,CAAM,EAE9C,IAAK,OACL,IAAK,QACH,OAAOoE,GAAU,KAAMjD,EAAQ9C,EAAQ2B,CAAM,EAE/C,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAOsE,GAAW,KAAMnD,EAAQ9C,EAAQ2B,CAAM,EAEhD,IAAK,SAEH,OAAOwE,GAAY,KAAMrD,EAAQ9C,EAAQ2B,CAAM,EAEjD,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOyE,EAAU,KAAMtD,EAAQ9C,EAAQ2B,CAAM,EAE/C,QACE,GAAIkC,EAAa,MAAM,IAAI,UAAU,qBAAuBjB,CAAQ,EACpEA,GAAY,GAAKA,GAAU,YAAY,EACvCiB,EAAc,EAClB,CAEJ,EAEAxC,EAAO,UAAU,OAAS,UAAkB,CAC1C,MAAO,CACL,KAAM,SACN,KAAM,MAAM,UAAU,MAAM,KAAK,KAAK,MAAQ,KAAM,CAAC,CACvD,CACF,EAEA,SAASgD,GAAYzC,EAAKvC,EAAOC,EAAK,CACpC,OAAID,IAAU,GAAKC,IAAQsC,EAAI,OACtBV,EAAO,cAAcU,CAAG,EAExBV,EAAO,cAAcU,EAAI,MAAMvC,EAAOC,CAAG,CAAC,CAErD,CAEA,SAAS4E,EAAUtC,EAAKvC,EAAOC,EAAK,CAClCA,EAAM,KAAK,IAAIsC,EAAI,OAAQtC,CAAG,EAC9B,IAAMgH,EAAM,CAAC,EACThI,EAAIe,EAER,KAAOf,EAAIgB,GAAK,CACd,IAAMiH,EAAY3E,EAAItD,CAAC,EACnBkI,EAAY,KACZC,EAAmBF,EAAY,IAAM,EAAIA,EAAY,IAAM,EAAIA,EAAY,IAAM,EAAI,EAEzF,GAAIjI,EAAImI,GAAoBnH,EAAK,CAC/B,IAAIoH,EAAYC,EAAWC,EAAYC,EAEvC,OAAQJ,EAAkB,CACxB,IAAK,GACCF,EAAY,MACdC,EAAYD,GAGd,MAEF,IAAK,GACHG,EAAa9E,EAAItD,EAAI,CAAC,GAEjBoI,EAAa,OAAS,MACzBG,GAAiBN,EAAY,KAAO,EAAIG,EAAa,GAEjDG,EAAgB,MAClBL,EAAYK,IAIhB,MAEF,IAAK,GACHH,EAAa9E,EAAItD,EAAI,CAAC,EACtBqI,EAAY/E,EAAItD,EAAI,CAAC,GAEhBoI,EAAa,OAAS,MAAQC,EAAY,OAAS,MACtDE,GAAiBN,EAAY,KAAO,IAAMG,EAAa,KAAO,EAAIC,EAAY,GAE1EE,EAAgB,OAASA,EAAgB,OAASA,EAAgB,SACpEL,EAAYK,IAIhB,MAEF,IAAK,GACHH,EAAa9E,EAAItD,EAAI,CAAC,EACtBqI,EAAY/E,EAAItD,EAAI,CAAC,EACrBsI,EAAahF,EAAItD,EAAI,CAAC,GAEjBoI,EAAa,OAAS,MAAQC,EAAY,OAAS,MAAQC,EAAa,OAAS,MACpFC,GAAiBN,EAAY,KAAO,IAAMG,EAAa,KAAO,IAAMC,EAAY,KAAO,EAAIC,EAAa,GAEpGC,EAAgB,OAASA,EAAgB,UAC3CL,EAAYK,GAIpB,CACF,CAEIL,IAAc,MAGhBA,EAAY,MACZC,EAAmB,GACVD,EAAY,QAErBA,GAAa,MACbF,EAAI,KAAKE,IAAc,GAAK,KAAO,KAAK,EACxCA,EAAY,MAAQA,EAAY,MAGlCF,EAAI,KAAKE,CAAS,EAClBlI,GAAKmI,CACP,CAEA,OAAOK,EAAsBR,CAAG,CAClC,CAKA,IAAMS,EAAuB,KAE7B,SAASD,EAAsBE,EAAY,CACzC,IAAMzI,EAAMyI,EAAW,OAEvB,GAAIzI,GAAOwI,EACT,OAAO,OAAO,aAAa,MAAM,OAAQC,CAAU,EAIrD,IAAIV,EAAM,GACNhI,EAAI,EAER,KAAOA,EAAIC,GACT+H,GAAO,OAAO,aAAa,MAAM,OAAQU,EAAW,MAAM1I,EAAGA,GAAKyI,CAAoB,CAAC,EAGzF,OAAOT,CACT,CAEA,SAASnC,GAAWvC,EAAKvC,EAAOC,EAAK,CACnC,IAAI2H,EAAM,GACV3H,EAAM,KAAK,IAAIsC,EAAI,OAAQtC,CAAG,EAE9B,QAAShB,EAAIe,EAAOf,EAAIgB,EAAK,EAAEhB,EAC7B2I,GAAO,OAAO,aAAarF,EAAItD,CAAC,EAAI,GAAG,EAGzC,OAAO2I,CACT,CAEA,SAAS7C,EAAYxC,EAAKvC,EAAOC,EAAK,CACpC,IAAI2H,EAAM,GACV3H,EAAM,KAAK,IAAIsC,EAAI,OAAQtC,CAAG,EAE9B,QAAShB,EAAIe,EAAOf,EAAIgB,EAAK,EAAEhB,EAC7B2I,GAAO,OAAO,aAAarF,EAAItD,CAAC,CAAC,EAGnC,OAAO2I,CACT,CAEA,SAAShD,EAASrC,EAAKvC,EAAOC,EAAK,CACjC,IAAMf,EAAMqD,EAAI,QACZ,CAACvC,GAASA,EAAQ,KAAGA,EAAQ,IAC7B,CAACC,GAAOA,EAAM,GAAKA,EAAMf,KAAKe,EAAMf,GACxC,IAAI2I,EAAM,GAEV,QAAS5I,EAAIe,EAAOf,EAAIgB,EAAK,EAAEhB,EAC7B4I,GAAOC,GAAoBvF,EAAItD,CAAC,CAAC,EAGnC,OAAO4I,CACT,CAEA,SAAS5C,EAAa1C,EAAKvC,EAAOC,EAAK,CACrC,IAAM8H,EAAQxF,EAAI,MAAMvC,EAAOC,CAAG,EAC9BgH,EAAM,GAEV,QAAShI,EAAI,EAAGA,EAAI8I,EAAM,OAAS,EAAG9I,GAAK,EACzCgI,GAAO,OAAO,aAAac,EAAM9I,CAAC,EAAI8I,EAAM9I,EAAI,CAAC,EAAI,GAAG,EAG1D,OAAOgI,CACT,CAEAjF,EAAO,UAAU,MAAQ,SAAehC,EAAOC,EAAK,CAClD,IAAMf,EAAM,KAAK,OACjBc,EAAQ,CAAC,CAACA,EACVC,EAAMA,IAAQ,OAAYf,EAAM,CAAC,CAACe,EAE9BD,EAAQ,GACVA,GAASd,EACLc,EAAQ,IAAGA,EAAQ,IACdA,EAAQd,IACjBc,EAAQd,GAGNe,EAAM,GACRA,GAAOf,EACHe,EAAM,IAAGA,EAAM,IACVA,EAAMf,IACfe,EAAMf,GAGJe,EAAMD,IAAOC,EAAMD,GACvB,IAAMgI,EAAS,KAAK,SAAShI,EAAOC,CAAG,EAEvC,cAAO,eAAe+H,EAAQhG,EAAO,SAAS,EACvCgG,CACT,EAMA,SAASC,EAAYtH,EAAQuH,EAAK5F,EAAQ,CACxC,GAAI3B,EAAS,IAAM,GAAKA,EAAS,EAAG,MAAM,IAAI,WAAW,oBAAoB,EAC7E,GAAIA,EAASuH,EAAM5F,EAAQ,MAAM,IAAI,WAAW,uCAAuC,CACzF,CAEAN,EAAO,UAAU,WAAaA,EAAO,UAAU,WAAa,SAAoBrB,EAAQjC,EAAYyJ,EAAU,CAC5GxH,EAASA,IAAW,EACpBjC,EAAaA,IAAe,EACvByJ,GAAUF,EAAYtH,EAAQjC,EAAY,KAAK,MAAM,EAC1D,IAAIkH,EAAM,KAAKjF,CAAM,EACjByH,EAAM,EACNnJ,EAAI,EAER,KAAO,EAAEA,EAAIP,IAAe0J,GAAO,MACjCxC,GAAO,KAAKjF,EAAS1B,CAAC,EAAImJ,EAG5B,OAAOxC,CACT,EAEA5D,EAAO,UAAU,WAAaA,EAAO,UAAU,WAAa,SAAoBrB,EAAQjC,EAAYyJ,EAAU,CAC5GxH,EAASA,IAAW,EACpBjC,EAAaA,IAAe,EAEvByJ,GACHF,EAAYtH,EAAQjC,EAAY,KAAK,MAAM,EAG7C,IAAIkH,EAAM,KAAKjF,EAAS,EAAEjC,CAAU,EAChC0J,EAAM,EAEV,KAAO1J,EAAa,IAAM0J,GAAO,MAC/BxC,GAAO,KAAKjF,EAAS,EAAEjC,CAAU,EAAI0J,EAGvC,OAAOxC,CACT,EAEA5D,EAAO,UAAU,UAAYA,EAAO,UAAU,UAAY,SAAmBrB,EAAQwH,EAAU,CAC7F,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,CACpB,EAEAqB,EAAO,UAAU,aAAeA,EAAO,UAAU,aAAe,SAAsBrB,EAAQwH,EAAU,CACtG,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,EAAI,KAAKA,EAAS,CAAC,GAAK,CAC5C,EAEAqB,EAAO,UAAU,aAAeA,EAAO,UAAU,aAAe,SAAsBrB,EAAQwH,EAAU,CACtG,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,GAAK,EAAI,KAAKA,EAAS,CAAC,CAC5C,EAEAqB,EAAO,UAAU,aAAeA,EAAO,UAAU,aAAe,SAAsBrB,EAAQwH,EAAU,CACtG,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,GACzC,KAAKA,CAAM,EAAI,KAAKA,EAAS,CAAC,GAAK,EAAI,KAAKA,EAAS,CAAC,GAAK,IAAM,KAAKA,EAAS,CAAC,EAAI,QAC9F,EAEAqB,EAAO,UAAU,aAAeA,EAAO,UAAU,aAAe,SAAsBrB,EAAQwH,EAAU,CACtG,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,EAAI,UAAY,KAAKA,EAAS,CAAC,GAAK,GAAK,KAAKA,EAAS,CAAC,GAAK,EAAI,KAAKA,EAAS,CAAC,EACpG,EAEAqB,EAAO,UAAU,gBAAkBqG,EAAmB,SAAyB1H,EAAQ,CACrFA,EAASA,IAAW,EACpB2H,GAAe3H,EAAQ,QAAQ,EAC/B,IAAM4H,EAAQ,KAAK5H,CAAM,EACnB6H,EAAO,KAAK7H,EAAS,CAAC,GAExB4H,IAAU,QAAaC,IAAS,SAClCC,GAAY9H,EAAQ,KAAK,OAAS,CAAC,EAGrC,IAAM+H,EAAKH,EAAQ,KAAK,EAAE5H,CAAM,EAAI,GAAK,EAAI,KAAK,EAAEA,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,GACxFgI,EAAK,KAAK,EAAEhI,CAAM,EAAI,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAI,KAAK,EAAEA,CAAM,EAAI,GAAK,GAAK6H,EAAO,GAAK,GAC7F,OAAO,OAAOE,CAAE,GAAK,OAAOC,CAAE,GAAK,OAAO,EAAE,EAC9C,CAAC,EACD3G,EAAO,UAAU,gBAAkBqG,EAAmB,SAAyB1H,EAAQ,CACrFA,EAASA,IAAW,EACpB2H,GAAe3H,EAAQ,QAAQ,EAC/B,IAAM4H,EAAQ,KAAK5H,CAAM,EACnB6H,EAAO,KAAK7H,EAAS,CAAC,GAExB4H,IAAU,QAAaC,IAAS,SAClCC,GAAY9H,EAAQ,KAAK,OAAS,CAAC,EAGrC,IAAMgI,EAAKJ,EAAQ,GAAK,GAAK,KAAK,EAAE5H,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAI,KAAK,EAAEA,CAAM,EACzF+H,EAAK,KAAK,EAAE/H,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAI6H,EAC3F,OAAQ,OAAOG,CAAE,GAAK,OAAO,EAAE,GAAK,OAAOD,CAAE,CAC/C,CAAC,EAED1G,EAAO,UAAU,UAAY,SAAmBrB,EAAQjC,EAAYyJ,EAAU,CAC5ExH,EAASA,IAAW,EACpBjC,EAAaA,IAAe,EACvByJ,GAAUF,EAAYtH,EAAQjC,EAAY,KAAK,MAAM,EAC1D,IAAIkH,EAAM,KAAKjF,CAAM,EACjByH,EAAM,EACNnJ,EAAI,EAER,KAAO,EAAEA,EAAIP,IAAe0J,GAAO,MACjCxC,GAAO,KAAKjF,EAAS1B,CAAC,EAAImJ,EAG5B,OAAAA,GAAO,IACHxC,GAAOwC,IAAKxC,GAAO,KAAK,IAAI,EAAG,EAAIlH,CAAU,GAC1CkH,CACT,EAEA5D,EAAO,UAAU,UAAY,SAAmBrB,EAAQjC,EAAYyJ,EAAU,CAC5ExH,EAASA,IAAW,EACpBjC,EAAaA,IAAe,EACvByJ,GAAUF,EAAYtH,EAAQjC,EAAY,KAAK,MAAM,EAC1D,IAAIO,EAAIP,EACJ0J,EAAM,EACNxC,EAAM,KAAKjF,EAAS,EAAE1B,CAAC,EAE3B,KAAOA,EAAI,IAAMmJ,GAAO,MACtBxC,GAAO,KAAKjF,EAAS,EAAE1B,CAAC,EAAImJ,EAG9B,OAAAA,GAAO,IACHxC,GAAOwC,IAAKxC,GAAO,KAAK,IAAI,EAAG,EAAIlH,CAAU,GAC1CkH,CACT,EAEA5D,EAAO,UAAU,SAAW,SAAkBrB,EAAQwH,EAAU,CAG9D,OAFAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC3C,KAAKA,CAAM,EAAI,KACb,IAAM,KAAKA,CAAM,EAAI,GAAK,GADA,KAAKA,CAAM,CAE/C,EAEAqB,EAAO,UAAU,YAAc,SAAqBrB,EAAQwH,EAAU,CACpExH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EACjD,IAAMiF,EAAM,KAAKjF,CAAM,EAAI,KAAKA,EAAS,CAAC,GAAK,EAC/C,OAAOiF,EAAM,MAAQA,EAAM,WAAaA,CAC1C,EAEA5D,EAAO,UAAU,YAAc,SAAqBrB,EAAQwH,EAAU,CACpExH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EACjD,IAAMiF,EAAM,KAAKjF,EAAS,CAAC,EAAI,KAAKA,CAAM,GAAK,EAC/C,OAAOiF,EAAM,MAAQA,EAAM,WAAaA,CAC1C,EAEA5D,EAAO,UAAU,YAAc,SAAqBrB,EAAQwH,EAAU,CACpE,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,EAAI,KAAKA,EAAS,CAAC,GAAK,EAAI,KAAKA,EAAS,CAAC,GAAK,GAAK,KAAKA,EAAS,CAAC,GAAK,EAC7F,EAEAqB,EAAO,UAAU,YAAc,SAAqBrB,EAAQwH,EAAU,CACpE,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,GAAK,GAAK,KAAKA,EAAS,CAAC,GAAK,GAAK,KAAKA,EAAS,CAAC,GAAK,EAAI,KAAKA,EAAS,CAAC,CAC9F,EAEAqB,EAAO,UAAU,eAAiBqG,EAAmB,SAAwB1H,EAAQ,CACnFA,EAASA,IAAW,EACpB2H,GAAe3H,EAAQ,QAAQ,EAC/B,IAAM4H,EAAQ,KAAK5H,CAAM,EACnB6H,EAAO,KAAK7H,EAAS,CAAC,GAExB4H,IAAU,QAAaC,IAAS,SAClCC,GAAY9H,EAAQ,KAAK,OAAS,CAAC,EAGrC,IAAMiF,EAAM,KAAKjF,EAAS,CAAC,EAAI,KAAKA,EAAS,CAAC,EAAI,GAAK,EAAI,KAAKA,EAAS,CAAC,EAAI,GAAK,IAAM6H,GAAQ,IAEjG,OAAQ,OAAO5C,CAAG,GAAK,OAAO,EAAE,GAAK,OAAO2C,EAAQ,KAAK,EAAE5H,CAAM,EAAI,GAAK,EAAI,KAAK,EAAEA,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAE,CACnI,CAAC,EACDqB,EAAO,UAAU,eAAiBqG,EAAmB,SAAwB1H,EAAQ,CACnFA,EAASA,IAAW,EACpB2H,GAAe3H,EAAQ,QAAQ,EAC/B,IAAM4H,EAAQ,KAAK5H,CAAM,EACnB6H,EAAO,KAAK7H,EAAS,CAAC,GAExB4H,IAAU,QAAaC,IAAS,SAClCC,GAAY9H,EAAQ,KAAK,OAAS,CAAC,EAGrC,IAAMiF,GAAO2C,GAAS,IACtB,KAAK,EAAE5H,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAI,KAAK,EAAEA,CAAM,EAClE,OAAQ,OAAOiF,CAAG,GAAK,OAAO,EAAE,GAAK,OAAO,KAAK,EAAEjF,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,GAAK,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAI6H,CAAI,CAClI,CAAC,EAEDxG,EAAO,UAAU,YAAc,SAAqBrB,EAAQwH,EAAU,CACpE,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1CmB,EAAQ,KAAK,KAAMnB,EAAQ,GAAM,GAAI,CAAC,CAC/C,EAEAqB,EAAO,UAAU,YAAc,SAAqBrB,EAAQwH,EAAU,CACpE,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1CmB,EAAQ,KAAK,KAAMnB,EAAQ,GAAO,GAAI,CAAC,CAChD,EAEAqB,EAAO,UAAU,aAAe,SAAsBrB,EAAQwH,EAAU,CACtE,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1CmB,EAAQ,KAAK,KAAMnB,EAAQ,GAAM,GAAI,CAAC,CAC/C,EAEAqB,EAAO,UAAU,aAAe,SAAsBrB,EAAQwH,EAAU,CACtE,OAAAxH,EAASA,IAAW,EACfwH,GAAUF,EAAYtH,EAAQ,EAAG,KAAK,MAAM,EAC1CmB,EAAQ,KAAK,KAAMnB,EAAQ,GAAO,GAAI,CAAC,CAChD,EAEA,SAASiI,EAASrG,EAAKhB,EAAOZ,EAAQuH,EAAK7C,EAAKwD,EAAK,CACnD,GAAI,CAAC7G,EAAO,SAASO,CAAG,EAAG,MAAM,IAAI,UAAU,6CAA+C,EAC9F,GAAIhB,EAAQ8D,GAAO9D,EAAQsH,EAAK,MAAM,IAAI,WAAW,mCAAqC,EAC1F,GAAIlI,EAASuH,EAAM3F,EAAI,OAAQ,MAAM,IAAI,WAAW,oBAAoB,CAC1E,CAEAP,EAAO,UAAU,YAAcA,EAAO,UAAU,YAAc,SAAqBT,EAAOZ,EAAQjC,EAAYyJ,EAAU,CAKtH,GAJA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACpBjC,EAAaA,IAAe,EAExB,CAACyJ,EAAU,CACb,IAAMW,EAAW,KAAK,IAAI,EAAG,EAAIpK,CAAU,EAAI,EAC/CkK,EAAS,KAAMrH,EAAOZ,EAAQjC,EAAYoK,EAAU,CAAC,CACvD,CAEA,IAAIV,EAAM,EACNnJ,EAAI,EAGR,IAFA,KAAK0B,CAAM,EAAIY,EAAQ,IAEhB,EAAEtC,EAAIP,IAAe0J,GAAO,MACjC,KAAKzH,EAAS1B,CAAC,EAAIsC,EAAQ6G,EAAM,IAGnC,OAAOzH,EAASjC,CAClB,EAEAsD,EAAO,UAAU,YAAcA,EAAO,UAAU,YAAc,SAAqBT,EAAOZ,EAAQjC,EAAYyJ,EAAU,CAKtH,GAJA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACpBjC,EAAaA,IAAe,EAExB,CAACyJ,EAAU,CACb,IAAMW,EAAW,KAAK,IAAI,EAAG,EAAIpK,CAAU,EAAI,EAC/CkK,EAAS,KAAMrH,EAAOZ,EAAQjC,EAAYoK,EAAU,CAAC,CACvD,CAEA,IAAI7J,EAAIP,EAAa,EACjB0J,EAAM,EAGV,IAFA,KAAKzH,EAAS1B,CAAC,EAAIsC,EAAQ,IAEpB,EAAEtC,GAAK,IAAMmJ,GAAO,MACzB,KAAKzH,EAAS1B,CAAC,EAAIsC,EAAQ6G,EAAM,IAGnC,OAAOzH,EAASjC,CAClB,EAEAsD,EAAO,UAAU,WAAaA,EAAO,UAAU,WAAa,SAAoBT,EAAOZ,EAAQwH,EAAU,CACvG,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,IAAK,CAAC,EACtD,KAAKA,CAAM,EAAIY,EAAQ,IAChBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,cAAgBA,EAAO,UAAU,cAAgB,SAAuBT,EAAOZ,EAAQwH,EAAU,CAChH,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,MAAO,CAAC,EACxD,KAAKA,CAAM,EAAIY,EAAQ,IACvB,KAAKZ,EAAS,CAAC,EAAIY,IAAU,EACtBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,cAAgBA,EAAO,UAAU,cAAgB,SAAuBT,EAAOZ,EAAQwH,EAAU,CAChH,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,MAAO,CAAC,EACxD,KAAKA,CAAM,EAAIY,IAAU,EACzB,KAAKZ,EAAS,CAAC,EAAIY,EAAQ,IACpBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,cAAgBA,EAAO,UAAU,cAAgB,SAAuBT,EAAOZ,EAAQwH,EAAU,CAChH,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,WAAY,CAAC,EAC7D,KAAKA,EAAS,CAAC,EAAIY,IAAU,GAC7B,KAAKZ,EAAS,CAAC,EAAIY,IAAU,GAC7B,KAAKZ,EAAS,CAAC,EAAIY,IAAU,EAC7B,KAAKZ,CAAM,EAAIY,EAAQ,IAChBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,cAAgBA,EAAO,UAAU,cAAgB,SAAuBT,EAAOZ,EAAQwH,EAAU,CAChH,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,WAAY,CAAC,EAC7D,KAAKA,CAAM,EAAIY,IAAU,GACzB,KAAKZ,EAAS,CAAC,EAAIY,IAAU,GAC7B,KAAKZ,EAAS,CAAC,EAAIY,IAAU,EAC7B,KAAKZ,EAAS,CAAC,EAAIY,EAAQ,IACpBZ,EAAS,CAClB,EAEA,SAASoI,EAAexG,EAAKhB,EAAOZ,EAAQkI,EAAKxD,EAAK,CACpD2D,GAAWzH,EAAOsH,EAAKxD,EAAK9C,EAAK5B,EAAQ,CAAC,EAC1C,IAAI+H,EAAK,OAAOnH,EAAQ,OAAO,UAAU,CAAC,EAC1CgB,EAAI5B,GAAQ,EAAI+H,EAChBA,EAAKA,GAAM,EACXnG,EAAI5B,GAAQ,EAAI+H,EAChBA,EAAKA,GAAM,EACXnG,EAAI5B,GAAQ,EAAI+H,EAChBA,EAAKA,GAAM,EACXnG,EAAI5B,GAAQ,EAAI+H,EAChB,IAAIC,EAAK,OAAOpH,GAAS,OAAO,EAAE,EAAI,OAAO,UAAU,CAAC,EACxD,OAAAgB,EAAI5B,GAAQ,EAAIgI,EAChBA,EAAKA,GAAM,EACXpG,EAAI5B,GAAQ,EAAIgI,EAChBA,EAAKA,GAAM,EACXpG,EAAI5B,GAAQ,EAAIgI,EAChBA,EAAKA,GAAM,EACXpG,EAAI5B,GAAQ,EAAIgI,EACThI,CACT,CAEA,SAASsI,GAAe1G,EAAKhB,EAAOZ,EAAQkI,EAAKxD,EAAK,CACpD2D,GAAWzH,EAAOsH,EAAKxD,EAAK9C,EAAK5B,EAAQ,CAAC,EAC1C,IAAI+H,EAAK,OAAOnH,EAAQ,OAAO,UAAU,CAAC,EAC1CgB,EAAI5B,EAAS,CAAC,EAAI+H,EAClBA,EAAKA,GAAM,EACXnG,EAAI5B,EAAS,CAAC,EAAI+H,EAClBA,EAAKA,GAAM,EACXnG,EAAI5B,EAAS,CAAC,EAAI+H,EAClBA,EAAKA,GAAM,EACXnG,EAAI5B,EAAS,CAAC,EAAI+H,EAClB,IAAIC,EAAK,OAAOpH,GAAS,OAAO,EAAE,EAAI,OAAO,UAAU,CAAC,EACxD,OAAAgB,EAAI5B,EAAS,CAAC,EAAIgI,EAClBA,EAAKA,GAAM,EACXpG,EAAI5B,EAAS,CAAC,EAAIgI,EAClBA,EAAKA,GAAM,EACXpG,EAAI5B,EAAS,CAAC,EAAIgI,EAClBA,EAAKA,GAAM,EACXpG,EAAI5B,CAAM,EAAIgI,EACPhI,EAAS,CAClB,CAEAqB,EAAO,UAAU,iBAAmBqG,EAAmB,SAA0B9G,EAAOZ,EAAS,EAAG,CAClG,OAAOoI,EAAe,KAAMxH,EAAOZ,EAAQ,OAAO,CAAC,EAAG,OAAO,oBAAoB,CAAC,CACpF,CAAC,EACDqB,EAAO,UAAU,iBAAmBqG,EAAmB,SAA0B9G,EAAOZ,EAAS,EAAG,CAClG,OAAOsI,GAAe,KAAM1H,EAAOZ,EAAQ,OAAO,CAAC,EAAG,OAAO,oBAAoB,CAAC,CACpF,CAAC,EAEDqB,EAAO,UAAU,WAAa,SAAoBT,EAAOZ,EAAQjC,EAAYyJ,EAAU,CAIrF,GAHA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EAEhB,CAACwH,EAAU,CACb,IAAMe,EAAQ,KAAK,IAAI,EAAG,EAAIxK,EAAa,CAAC,EAC5CkK,EAAS,KAAMrH,EAAOZ,EAAQjC,EAAYwK,EAAQ,EAAG,CAACA,CAAK,CAC7D,CAEA,IAAIjK,EAAI,EACJmJ,EAAM,EACNe,EAAM,EAGV,IAFA,KAAKxI,CAAM,EAAIY,EAAQ,IAEhB,EAAEtC,EAAIP,IAAe0J,GAAO,MAC7B7G,EAAQ,GAAK4H,IAAQ,GAAK,KAAKxI,EAAS1B,EAAI,CAAC,IAAM,IACrDkK,EAAM,GAGR,KAAKxI,EAAS1B,CAAC,GAAKsC,EAAQ6G,GAAO,GAAKe,EAAM,IAGhD,OAAOxI,EAASjC,CAClB,EAEAsD,EAAO,UAAU,WAAa,SAAoBT,EAAOZ,EAAQjC,EAAYyJ,EAAU,CAIrF,GAHA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EAEhB,CAACwH,EAAU,CACb,IAAMe,EAAQ,KAAK,IAAI,EAAG,EAAIxK,EAAa,CAAC,EAC5CkK,EAAS,KAAMrH,EAAOZ,EAAQjC,EAAYwK,EAAQ,EAAG,CAACA,CAAK,CAC7D,CAEA,IAAIjK,EAAIP,EAAa,EACjB0J,EAAM,EACNe,EAAM,EAGV,IAFA,KAAKxI,EAAS1B,CAAC,EAAIsC,EAAQ,IAEpB,EAAEtC,GAAK,IAAMmJ,GAAO,MACrB7G,EAAQ,GAAK4H,IAAQ,GAAK,KAAKxI,EAAS1B,EAAI,CAAC,IAAM,IACrDkK,EAAM,GAGR,KAAKxI,EAAS1B,CAAC,GAAKsC,EAAQ6G,GAAO,GAAKe,EAAM,IAGhD,OAAOxI,EAASjC,CAClB,EAEAsD,EAAO,UAAU,UAAY,SAAmBT,EAAOZ,EAAQwH,EAAU,CACvE,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,IAAK,IAAI,EACrDY,EAAQ,IAAGA,EAAQ,IAAMA,EAAQ,GACrC,KAAKZ,CAAM,EAAIY,EAAQ,IAChBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,aAAe,SAAsBT,EAAOZ,EAAQwH,EAAU,CAC7E,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,MAAO,MAAM,EAC7D,KAAKA,CAAM,EAAIY,EAAQ,IACvB,KAAKZ,EAAS,CAAC,EAAIY,IAAU,EACtBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,aAAe,SAAsBT,EAAOZ,EAAQwH,EAAU,CAC7E,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,MAAO,MAAM,EAC7D,KAAKA,CAAM,EAAIY,IAAU,EACzB,KAAKZ,EAAS,CAAC,EAAIY,EAAQ,IACpBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,aAAe,SAAsBT,EAAOZ,EAAQwH,EAAU,CAC7E,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,WAAY,WAAW,EACvE,KAAKA,CAAM,EAAIY,EAAQ,IACvB,KAAKZ,EAAS,CAAC,EAAIY,IAAU,EAC7B,KAAKZ,EAAS,CAAC,EAAIY,IAAU,GAC7B,KAAKZ,EAAS,CAAC,EAAIY,IAAU,GACtBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,aAAe,SAAsBT,EAAOZ,EAAQwH,EAAU,CAC7E,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EACfwH,GAAUS,EAAS,KAAMrH,EAAOZ,EAAQ,EAAG,WAAY,WAAW,EACnEY,EAAQ,IAAGA,EAAQ,WAAaA,EAAQ,GAC5C,KAAKZ,CAAM,EAAIY,IAAU,GACzB,KAAKZ,EAAS,CAAC,EAAIY,IAAU,GAC7B,KAAKZ,EAAS,CAAC,EAAIY,IAAU,EAC7B,KAAKZ,EAAS,CAAC,EAAIY,EAAQ,IACpBZ,EAAS,CAClB,EAEAqB,EAAO,UAAU,gBAAkBqG,EAAmB,SAAyB9G,EAAOZ,EAAS,EAAG,CAChG,OAAOoI,EAAe,KAAMxH,EAAOZ,EAAQ,CAAC,OAAO,oBAAoB,EAAG,OAAO,oBAAoB,CAAC,CACxG,CAAC,EACDqB,EAAO,UAAU,gBAAkBqG,EAAmB,SAAyB9G,EAAOZ,EAAS,EAAG,CAChG,OAAOsI,GAAe,KAAM1H,EAAOZ,EAAQ,CAAC,OAAO,oBAAoB,EAAG,OAAO,oBAAoB,CAAC,CACxG,CAAC,EAED,SAASyI,GAAa7G,EAAKhB,EAAOZ,EAAQuH,EAAK7C,EAAKwD,EAAK,CACvD,GAAIlI,EAASuH,EAAM3F,EAAI,OAAQ,MAAM,IAAI,WAAW,oBAAoB,EACxE,GAAI5B,EAAS,EAAG,MAAM,IAAI,WAAW,oBAAoB,CAC3D,CAEA,SAAS0I,GAAW9G,EAAKhB,EAAOZ,EAAQ2I,EAAcnB,EAAU,CAC9D,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EAEfwH,GACHiB,GAAa7G,EAAKhB,EAAOZ,EAAQ,CAAC,EAGpCmB,EAAQ,MAAMS,EAAKhB,EAAOZ,EAAQ2I,EAAc,GAAI,CAAC,EAC9C3I,EAAS,CAClB,CAEAqB,EAAO,UAAU,aAAe,SAAsBT,EAAOZ,EAAQwH,EAAU,CAC7E,OAAOkB,GAAW,KAAM9H,EAAOZ,EAAQ,GAAMwH,CAAQ,CACvD,EAEAnG,EAAO,UAAU,aAAe,SAAsBT,EAAOZ,EAAQwH,EAAU,CAC7E,OAAOkB,GAAW,KAAM9H,EAAOZ,EAAQ,GAAOwH,CAAQ,CACxD,EAEA,SAASoB,GAAYhH,EAAKhB,EAAOZ,EAAQ2I,EAAcnB,EAAU,CAC/D,OAAA5G,EAAQ,CAACA,EACTZ,EAASA,IAAW,EAEfwH,GACHiB,GAAa7G,EAAKhB,EAAOZ,EAAQ,CAAC,EAGpCmB,EAAQ,MAAMS,EAAKhB,EAAOZ,EAAQ2I,EAAc,GAAI,CAAC,EAC9C3I,EAAS,CAClB,CAEAqB,EAAO,UAAU,cAAgB,SAAuBT,EAAOZ,EAAQwH,EAAU,CAC/E,OAAOoB,GAAY,KAAMhI,EAAOZ,EAAQ,GAAMwH,CAAQ,CACxD,EAEAnG,EAAO,UAAU,cAAgB,SAAuBT,EAAOZ,EAAQwH,EAAU,CAC/E,OAAOoB,GAAY,KAAMhI,EAAOZ,EAAQ,GAAOwH,CAAQ,CACzD,EAGAnG,EAAO,UAAU,KAAO,SAAcsD,EAAQkE,EAAaxJ,EAAOC,EAAK,CACrE,GAAI,CAAC+B,EAAO,SAASsD,CAAM,EAAG,MAAM,IAAI,UAAU,6BAA6B,EAQ/E,GAPKtF,IAAOA,EAAQ,GAChB,CAACC,GAAOA,IAAQ,IAAGA,EAAM,KAAK,QAC9BuJ,GAAelE,EAAO,SAAQkE,EAAclE,EAAO,QAClDkE,IAAaA,EAAc,GAC5BvJ,EAAM,GAAKA,EAAMD,IAAOC,EAAMD,GAE9BC,IAAQD,GACRsF,EAAO,SAAW,GAAK,KAAK,SAAW,EAAG,MAAO,GAErD,GAAIkE,EAAc,EAChB,MAAM,IAAI,WAAW,2BAA2B,EAGlD,GAAIxJ,EAAQ,GAAKA,GAAS,KAAK,OAAQ,MAAM,IAAI,WAAW,oBAAoB,EAChF,GAAIC,EAAM,EAAG,MAAM,IAAI,WAAW,yBAAyB,EAEvDA,EAAM,KAAK,SAAQA,EAAM,KAAK,QAE9BqF,EAAO,OAASkE,EAAcvJ,EAAMD,IACtCC,EAAMqF,EAAO,OAASkE,EAAcxJ,GAGtC,IAAMd,EAAMe,EAAMD,EAElB,OAAI,OAASsF,GAAU,OAAO,WAAW,UAAU,YAAe,WAEhE,KAAK,WAAWkE,EAAaxJ,EAAOC,CAAG,EAEvC,WAAW,UAAU,IAAI,KAAKqF,EAAQ,KAAK,SAAStF,EAAOC,CAAG,EAAGuJ,CAAW,EAGvEtK,CACT,EAMA8C,EAAO,UAAU,KAAO,SAAc4D,EAAK5F,EAAOC,EAAKsD,EAAU,CAE/D,GAAI,OAAOqC,GAAQ,SAAU,CAU3B,GATI,OAAO5F,GAAU,UACnBuD,EAAWvD,EACXA,EAAQ,EACRC,EAAM,KAAK,QACF,OAAOA,GAAQ,WACxBsD,EAAWtD,EACXA,EAAM,KAAK,QAGTsD,IAAa,QAAa,OAAOA,GAAa,SAChD,MAAM,IAAI,UAAU,2BAA2B,EAGjD,GAAI,OAAOA,GAAa,UAAY,CAACvB,EAAO,WAAWuB,CAAQ,EAC7D,MAAM,IAAI,UAAU,qBAAuBA,CAAQ,EAGrD,GAAIqC,EAAI,SAAW,EAAG,CACpB,IAAM5G,EAAO4G,EAAI,WAAW,CAAC,GAEzBrC,IAAa,QAAUvE,EAAO,KAAOuE,IAAa,YAEpDqC,EAAM5G,EAEV,CACF,MAAW,OAAO4G,GAAQ,SACxBA,EAAMA,EAAM,IACH,OAAOA,GAAQ,YACxBA,EAAM,OAAOA,CAAG,GAIlB,GAAI5F,EAAQ,GAAK,KAAK,OAASA,GAAS,KAAK,OAASC,EACpD,MAAM,IAAI,WAAW,oBAAoB,EAG3C,GAAIA,GAAOD,EACT,OAAO,KAGTA,EAAQA,IAAU,EAClBC,EAAMA,IAAQ,OAAY,KAAK,OAASA,IAAQ,EAC3C2F,IAAKA,EAAM,GAChB,IAAI3G,EAEJ,GAAI,OAAO2G,GAAQ,SACjB,IAAK3G,EAAIe,EAAOf,EAAIgB,EAAK,EAAEhB,EACzB,KAAKA,CAAC,EAAI2G,MAEP,CACL,IAAMmC,EAAQ/F,EAAO,SAAS4D,CAAG,EAAIA,EAAM5D,EAAO,KAAK4D,EAAKrC,CAAQ,EAC9DrE,EAAM6I,EAAM,OAElB,GAAI7I,IAAQ,EACV,MAAM,IAAI,UAAU,cAAiB0G,EAAM,mCAAsC,EAGnF,IAAK3G,EAAI,EAAGA,EAAIgB,EAAMD,EAAO,EAAEf,EAC7B,KAAKA,EAAIe,CAAK,EAAI+H,EAAM9I,EAAIC,CAAG,CAEnC,CAEA,OAAO,IACT,EAKA,IAAMuK,GAAS,CAAC,EAEhB,SAASC,GAAEC,EAAKC,EAAYC,EAAM,CAChCJ,GAAOE,CAAG,EAAI,cAAwBE,CAAK,CACzC,aAAc,CACZ,MAAM,EACN,OAAO,eAAe,KAAM,UAAW,CACrC,MAAOD,EAAW,MAAM,KAAM,SAAS,EACvC,SAAU,GACV,aAAc,EAChB,CAAC,EAED,KAAK,KAAO,GAAG,KAAK,IAAI,KAAKD,CAAG,IAGhC,KAAK,MAGL,OAAO,KAAK,IACd,CAEA,IAAI,MAAO,CACT,OAAOA,CACT,CAEA,IAAI,KAAKpI,EAAO,CACd,OAAO,eAAe,KAAM,OAAQ,CAClC,aAAc,GACd,WAAY,GACZ,MAAAA,EACA,SAAU,EACZ,CAAC,CACH,CAEA,UAAW,CACT,MAAO,GAAG,KAAK,IAAI,KAAKoI,CAAG,MAAM,KAAK,OAAO,EAC/C,CAEF,CACF,CAEAD,GAAE,2BAA4B,SAAUI,EAAM,CAC5C,OAAIA,EACK,GAAGA,CAAI,+BAGT,gDACT,EAAG,UAAU,EACbJ,GAAE,uBAAwB,SAAUI,EAAMpG,EAAQ,CAChD,MAAO,QAAQoG,CAAI,oDAAoD,OAAOpG,CAAM,EACtF,EAAG,SAAS,EACZgG,GAAE,mBAAoB,SAAUtE,EAAK2E,EAAOC,EAAO,CACjD,IAAIC,EAAM,iBAAiB7E,CAAG,qBAC1B8E,EAAWF,EAEf,OAAI,OAAO,UAAUA,CAAK,GAAK,KAAK,IAAIA,CAAK,EAAI,GAAK,GACpDE,EAAWC,GAAsB,OAAOH,CAAK,CAAC,EACrC,OAAOA,GAAU,WAC1BE,EAAW,OAAOF,CAAK,GAEnBA,EAAQ,OAAO,CAAC,GAAK,OAAO,EAAE,GAAKA,EAAQ,EAAE,OAAO,CAAC,GAAK,OAAO,EAAE,MACrEE,EAAWC,GAAsBD,CAAQ,GAG3CA,GAAY,KAGdD,GAAO,eAAeF,CAAK,cAAcG,CAAQ,GAC1CD,CACT,EAAG,UAAU,EAEb,SAASE,GAAsBvE,EAAK,CAClC,IAAIqB,EAAM,GACNhI,EAAI2G,EAAI,OACN5F,EAAQ4F,EAAI,CAAC,IAAM,IAAM,EAAI,EAEnC,KAAO3G,GAAKe,EAAQ,EAAGf,GAAK,EAC1BgI,EAAM,IAAIrB,EAAI,MAAM3G,EAAI,EAAGA,CAAC,CAAC,GAAGgI,CAAG,GAGrC,MAAO,GAAGrB,EAAI,MAAM,EAAG3G,CAAC,CAAC,GAAGgI,CAAG,EACjC,CAIA,SAASmD,GAAY7H,EAAK5B,EAAQjC,EAAY,CAC5C4J,GAAe3H,EAAQ,QAAQ,GAE3B4B,EAAI5B,CAAM,IAAM,QAAa4B,EAAI5B,EAASjC,CAAU,IAAM,SAC5D+J,GAAY9H,EAAQ4B,EAAI,QAAU7D,EAAa,EAAE,CAErD,CAEA,SAASsK,GAAWzH,EAAOsH,EAAKxD,EAAK9C,EAAK5B,EAAQjC,EAAY,CAC5D,GAAI6C,EAAQ8D,GAAO9D,EAAQsH,EAAK,CAC9B,IAAM1D,EAAI,OAAO0D,GAAQ,SAAW,IAAM,GACtCkB,EAEJ,MAAIrL,EAAa,EACXmK,IAAQ,GAAKA,IAAQ,OAAO,CAAC,EAC/BkB,EAAQ,OAAO5E,CAAC,WAAWA,CAAC,QAAQzG,EAAa,GAAK,CAAC,GAAGyG,CAAC,GAE3D4E,EAAQ,SAAS5E,CAAC,QAAQzG,EAAa,GAAK,EAAI,CAAC,GAAGyG,CAAC,iBAAsBzG,EAAa,GAAK,EAAI,CAAC,GAAGyG,CAAC,GAGxG4E,EAAQ,MAAMlB,CAAG,GAAG1D,CAAC,WAAWE,CAAG,GAAGF,CAAC,GAGnC,IAAIsE,GAAO,iBAAiB,QAASM,EAAOxI,CAAK,CACzD,CAEA6I,GAAY7H,EAAK5B,EAAQjC,CAAU,CACrC,CAEA,SAAS4J,GAAe/G,EAAOuI,EAAM,CACnC,GAAI,OAAOvI,GAAU,SACnB,MAAM,IAAIkI,GAAO,qBAAqBK,EAAM,SAAUvI,CAAK,CAE/D,CAEA,SAASkH,GAAYlH,EAAOe,EAAQ+H,EAAM,CACxC,MAAI,KAAK,MAAM9I,CAAK,IAAMA,GACxB+G,GAAe/G,EAAO8I,CAAI,EACpB,IAAIZ,GAAO,iBAAiBY,GAAQ,SAAU,aAAc9I,CAAK,GAGrEe,EAAS,EACL,IAAImH,GAAO,yBAGb,IAAIA,GAAO,iBAAiBY,GAAQ,SAAU,MAAMA,EAAO,EAAI,CAAC,WAAW/H,CAAM,GAAIf,CAAK,CAClG,CAIA,IAAM+I,GAAoB,oBAE1B,SAASC,GAAYnF,EAAK,CAMxB,GAJAA,EAAMA,EAAI,MAAM,GAAG,EAAE,CAAC,EAEtBA,EAAMA,EAAI,KAAK,EAAE,QAAQkF,GAAmB,EAAE,EAE1ClF,EAAI,OAAS,EAAG,MAAO,GAE3B,KAAOA,EAAI,OAAS,IAAM,GACxBA,EAAMA,EAAM,IAGd,OAAOA,CACT,CAEA,SAASX,GAAYhB,EAAQ+G,EAAO,CAClCA,EAAQA,GAAS,IACjB,IAAIrD,EACE7E,EAASmB,EAAO,OAClBgH,EAAgB,KACd1C,EAAQ,CAAC,EAEf,QAAS9I,EAAI,EAAGA,EAAIqD,EAAQ,EAAErD,EAAG,CAG/B,GAFAkI,EAAY1D,EAAO,WAAWxE,CAAC,EAE3BkI,EAAY,OAASA,EAAY,MAAO,CAE1C,GAAI,CAACsD,EAAe,CAElB,GAAItD,EAAY,MAAO,EAEhBqD,GAAS,GAAK,IAAIzC,EAAM,KAAK,IAAK,IAAK,GAAG,EAC/C,QACF,SAAW9I,EAAI,IAAMqD,EAAQ,EAEtBkI,GAAS,GAAK,IAAIzC,EAAM,KAAK,IAAK,IAAK,GAAG,EAC/C,QACF,CAGA0C,EAAgBtD,EAChB,QACF,CAGA,GAAIA,EAAY,MAAO,EAChBqD,GAAS,GAAK,IAAIzC,EAAM,KAAK,IAAK,IAAK,GAAG,EAC/C0C,EAAgBtD,EAChB,QACF,CAGAA,GAAasD,EAAgB,OAAS,GAAKtD,EAAY,OAAS,KAClE,MAAWsD,IAEJD,GAAS,GAAK,IAAIzC,EAAM,KAAK,IAAK,IAAK,GAAG,EAKjD,GAFA0C,EAAgB,KAEZtD,EAAY,IAAK,CACnB,IAAKqD,GAAS,GAAK,EAAG,MACtBzC,EAAM,KAAKZ,CAAS,CACtB,SAAWA,EAAY,KAAM,CAC3B,IAAKqD,GAAS,GAAK,EAAG,MACtBzC,EAAM,KAAKZ,GAAa,EAAI,IAAKA,EAAY,GAAK,GAAG,CACvD,SAAWA,EAAY,MAAO,CAC5B,IAAKqD,GAAS,GAAK,EAAG,MACtBzC,EAAM,KAAKZ,GAAa,GAAK,IAAKA,GAAa,EAAI,GAAK,IAAKA,EAAY,GAAK,GAAG,CACnF,SAAWA,EAAY,QAAS,CAC9B,IAAKqD,GAAS,GAAK,EAAG,MACtBzC,EAAM,KAAKZ,GAAa,GAAK,IAAKA,GAAa,GAAK,GAAK,IAAKA,GAAa,EAAI,GAAK,IAAKA,EAAY,GAAK,GAAG,CAC/G,KACE,OAAM,IAAI,MAAM,oBAAoB,CAExC,CAEA,OAAOY,CACT,CAEA,SAASlB,GAAazB,EAAK,CACzB,IAAMsF,EAAY,CAAC,EAEnB,QAASzL,EAAI,EAAGA,EAAImG,EAAI,OAAQ,EAAEnG,EAEhCyL,EAAU,KAAKtF,EAAI,WAAWnG,CAAC,EAAI,GAAG,EAGxC,OAAOyL,CACT,CAEA,SAAS1D,GAAe5B,EAAKoF,EAAO,CAClC,IAAIhJ,EAAGmH,EAAID,EACLgC,EAAY,CAAC,EAEnB,QAASzL,EAAI,EAAGA,EAAImG,EAAI,QACjB,GAAAoF,GAAS,GAAK,GADW,EAAEvL,EAEhCuC,EAAI4D,EAAI,WAAWnG,CAAC,EACpB0J,EAAKnH,GAAK,EACVkH,EAAKlH,EAAI,IACTkJ,EAAU,KAAKhC,CAAE,EACjBgC,EAAU,KAAK/B,CAAE,EAGnB,OAAO+B,CACT,CAEA,SAAShG,GAAcU,EAAK,CAC1B,OAAOvD,EAAO,YAAY0I,GAAYnF,CAAG,CAAC,CAC5C,CAEA,SAASuB,GAAWgE,EAAKC,EAAKjK,EAAQ2B,EAAQ,CAC5C,IAAIrD,EAEJ,IAAKA,EAAI,EAAGA,EAAIqD,GACV,EAAArD,EAAI0B,GAAUiK,EAAI,QAAU3L,GAAK0L,EAAI,QADnB,EAAE1L,EAExB2L,EAAI3L,EAAI0B,CAAM,EAAIgK,EAAI1L,CAAC,EAGzB,OAAOA,CACT,CAKA,SAAS6D,EAAWkB,EAAKqG,EAAM,CAC7B,OAAOrG,aAAeqG,GAAQrG,GAAO,MAAQA,EAAI,aAAe,MAAQA,EAAI,YAAY,MAAQ,MAAQA,EAAI,YAAY,OAASqG,EAAK,IACxI,CAEA,SAASpG,GAAYD,EAAK,CAExB,OAAOA,IAAQA,CACjB,CAIA,IAAM8D,GAAsB,UAAY,CACtC,IAAM+C,EAAW,mBACXC,EAAQ,IAAI,MAAM,GAAG,EAE3B,QAAS7L,EAAI,EAAGA,EAAI,GAAI,EAAEA,EAAG,CAC3B,IAAM8L,EAAM9L,EAAI,GAEhB,QAASoH,EAAI,EAAGA,EAAI,GAAI,EAAEA,EACxByE,EAAMC,EAAM1E,CAAC,EAAIwE,EAAS5L,CAAC,EAAI4L,EAASxE,CAAC,CAE7C,CAEA,OAAOyE,CACT,EAAE,EAGF,SAASzC,EAAmB2C,EAAI,CAC9B,OAAO,OAAO,OAAW,IAAcC,GAAyBD,CAClE,CAEA,SAASC,IAAyB,CAChC,MAAM,IAAI,MAAM,sBAAsB,CACxC,CAEA,OAAOvJ,CACT,CAEA,IAAMwJ,EAAUtJ,GAAI,EACpBsJ,EAAQ,OAAWA,EAAQ,WAAeA,EAAQ,kBAAsBA,EAAQ,WAEhF,IAAIlJ,EAASkJ,EAAQ,OACjBC,GAAoBD,EAAQ,kBAC5BE,GAAaF,EAAQ,WCpwEzB,IAAMG,EAAN,MAAMC,UAAiB,KAAM,CAC3B,YAAYC,EAAMC,EAASC,KAAYC,EAAU,CAC5C,MAAM,QAAQF,CAAO,IAAGA,EAAUA,EAAQ,KAAK,GAAG,EAAE,KAAK,GAC5D,MAAMA,CAAO,EACV,MAAM,oBAAsB,QAC7B,MAAM,kBAAkB,KAAMF,CAAQ,EAExC,KAAK,KAAOC,EACZ,QAAUI,KAAWD,EACnB,QAAUE,KAAOD,EAAQ,CACvB,IAAME,EAAQF,EAAQC,CAAG,EACzB,KAAKA,CAAG,EAAIE,EAAO,SAASD,CAAK,EAAIA,EAAM,SAASJ,EAAQ,QAAQ,EAAII,GAAS,KAAOA,EAAQ,KAAK,MAAM,KAAK,UAAUA,CAAK,CAAC,CAClI,CAEJ,CACF,ECfA,IAAME,GAAY,SAASC,EAAI,CAC7B,OAAQ,OAAOA,GAAQ,UAAYA,IAAQ,MAAQ,CAAC,MAAM,QAAQA,CAAG,CACvE,ECCA,IAAMC,GAA0B,SAASC,EAAQ,CAC/C,IAAMC,EAAoB,CAAC,EAC3B,QAAQC,EAAI,EAAGC,EAAIH,EAAQ,OAAQE,EAAIC,EAAGD,IAAI,CAC5C,IAAME,EAASJ,EAAQE,CAAC,EACxB,GAA2BE,GAAW,MAAQA,IAAW,GACvDH,EAAkBC,CAAC,EAAI,CAAE,SAAU,EAAK,UACjC,OAAOE,GAAW,SACzBH,EAAkBC,CAAC,EAAI,CAAE,KAAME,CAAO,UAC/BC,GAAUD,CAAM,EAAE,CACzB,GAAG,OAAOA,EAAO,MAAS,SACxB,MAAM,IAAIE,EAAS,kCAAmC,CACpD,+BACA,2CAA2CJ,CAAC,GAC5C,kCACF,CAAC,EAEHD,EAAkBC,CAAC,EAAIE,CACzB,KACE,OAAM,IAAIE,EAAS,gCAAiC,CAClD,6BACA,uCACA,OAAO,KAAK,UAAUF,CAAM,CAAC,gBAAgBF,CAAC,EAChD,CAAC,CAEL,CACA,OAAOD,CACT,EC7BA,IAAMM,GAAN,KAAsB,CACpB,YAAYC,EAAK,IAAI,CACnB,KAAK,KAAOA,EACZ,KAAK,OAAS,EACd,KAAK,IAAMC,EAAO,YAAYD,CAAI,CACpC,CACA,QAAQE,EAAI,CACV,GAAGD,EAAO,SAASC,CAAG,EAAE,CACtB,IAAMC,EAAS,KAAK,OAASD,EAAI,OACjC,GAAGC,GAAU,KAAK,OAChB,KAAK,OAAO,EACTA,GAAU,KAAK,MAChB,MAAM,MAAM,sBAAsB,EAGtC,IAAMC,EAAM,KAAK,IACjB,KAAK,IAAMH,EAAO,YAAY,KAAK,IAAI,EACvCC,EAAI,KAAK,KAAK,IAAK,CAAC,EACpBE,EAAI,KAAK,KAAK,IAAKF,EAAI,MAAM,EAC7B,KAAK,QAAUA,EAAI,MACrB,KAAK,CACH,IAAMC,EAAS,KAAK,SACjBA,IAAW,KAAK,MACjB,KAAK,OAAO,EAEd,IAAMC,EAAM,KAAK,MAAM,EACvB,KAAK,IAAI,CAAC,EAAIF,EACdE,EAAI,KAAK,KAAK,IAAI,EAAG,EAAGD,CAAM,CAChC,CACF,CACA,OAAOD,EAAI,CACT,IAAMC,EAAS,KAAK,SACjBA,IAAW,KAAK,MACjB,KAAK,OAAO,EAEd,KAAK,IAAIA,CAAM,EAAID,CACrB,CACA,OAAO,CACL,OAAOD,EAAO,KAAK,KAAK,IAAI,MAAM,EAAG,KAAK,MAAM,CAAC,CACnD,CACA,QAAQ,CACN,IAAME,EAAS,KAAK,OACpB,KAAK,KAAO,KAAK,KAAO,EACxB,IAAMC,EAAMH,EAAO,YAAY,KAAK,IAAI,EACxC,KAAK,IAAI,KAAKG,EAAI,EAAG,EAAGD,CAAM,EAC9B,KAAK,IAAMC,CACb,CACA,SAASC,EAAS,CAChB,OAAGA,EACM,KAAK,IAAI,MAAM,EAAG,KAAK,MAAM,EAAE,SAASA,CAAQ,EAEhD,WAAW,UAAU,MAAM,KAAK,KAAK,IAAI,MAAM,EAAG,KAAK,MAAM,CAAC,CAEzE,CACA,QAAQ,CACN,OAAO,KAAK,SAAS,MAAM,CAC7B,CACA,OAAO,CACL,KAAK,OAAS,CAChB,CACF,EAEOC,GAAQP,GCxDf,IAAMQ,GAAK,GACLC,GAAK,GACLC,GAAK,GACLC,GAAQ,GACRC,GAAM,EAENC,GAAa,SAASC,EAAQ,CAClC,MAAO,CACL,WAAY,GACZ,cAAe,EACf,UAAWA,EAAQ,cACnB,WAAY,GAEZ,MAAO,OACP,QAASA,EAAQ,YAAc,EAC/B,SAAU,GACV,cAAeC,EAAO,SAASD,EAAQ,MAAM,GAAKC,EAAO,SAASD,EAAQ,KAAK,GAAKC,EAAO,QAAQD,EAAQ,OAAQA,EAAQ,KAAK,IAAM,EAEtI,qBAAsB,MAAM,QAAQA,EAAQ,OAAO,EAAIA,EAAQ,QAAQ,OAAS,OAChF,MAAO,IAAIE,GAAiB,EAAE,EAC9B,mBAAoBF,EAAQ,0BAC5B,iBAAkB,KAAK,IAErBA,EAAQ,UAAY,KAAOA,EAAQ,QAAQ,OAAS,EAEpD,GAAGA,EAAQ,UAAU,IAAKG,GAAcA,EAAU,MAAM,EAExDH,EAAQ,QAAU,KAAOA,EAAQ,MAAM,OAAS,CAClD,EACA,YAAa,OACb,QAAS,GACT,KAAM,GACN,UAAW,IAAIE,GAAiB,GAAG,EACnC,OAAQ,CAAC,EACT,eAAgB,GAChB,cAAe,EACf,yBAA0BF,EAAQ,iBAAiB,SAAW,EAAI,EAAI,KAAK,IAAI,GAAGA,EAAQ,iBAAiB,IAAKI,GAAMA,EAAE,MAAM,CAAC,EAC/H,UAAW,CAACH,EAAO,KAAK,IAAKD,EAAQ,QAAQ,EAAE,CAAC,EAAGC,EAAO,KAAK,IAAMD,EAAQ,QAAQ,EAAE,CAAC,CAAC,EACzF,WAAY,GACZ,gBAAiB,GACjB,SAAU,CACRC,EAAO,KAAKA,EAAO,KAAK,CAACN,EAAE,EAAG,MAAM,EAAE,SAAS,EAAGK,EAAQ,QAAQ,EAClEC,EAAO,KAAKA,EAAO,KAAK,CAACL,EAAE,EAAG,MAAM,EAAE,SAAS,EAAGI,EAAQ,QAAQ,EAClEC,EAAO,KAAKA,EAAO,KAAK,CAACP,EAAE,EAAG,MAAM,EAAE,SAAS,EAAGM,EAAQ,QAAQ,EAClEC,EAAO,KAAKA,EAAO,KAAK,CAACJ,EAAK,EAAG,MAAM,EAAE,SAAS,EAAGG,EAAQ,QAAQ,EACrEC,EAAO,KAAKA,EAAO,KAAK,CAACH,EAAG,EAAG,MAAM,EAAE,SAAS,EAAGE,EAAQ,QAAQ,CACrE,CACF,CACF,ECtDA,IAAMK,GAAa,SAASC,EAAI,CAC9B,OAAOA,EAAI,QAAQ,WAAY,SAASC,EAAGC,EAAM,CAC/C,MAAO,IAAMA,EAAM,YAAY,CACjC,CAAC,CACH,ECAA,IAAMC,GAAoB,SAASC,EAAK,CACtC,IAAMC,EAAU,CAAC,EAEjB,QAAUC,KAAOF,EACfC,EAAQE,GAAWD,CAAG,CAAC,EAAIF,EAAKE,CAAG,EAKrC,GAAGD,EAAQ,WAAa,QAAaA,EAAQ,WAAa,GACxDA,EAAQ,SAAW,eACZA,EAAQ,WAAa,MAAQA,EAAQ,WAAa,GACzDA,EAAQ,SAAW,aACZ,OAAOA,EAAQ,UAAa,UAAYA,EAAQ,WAAa,KACpE,MAAM,IAAIG,EAAS,8BAA+B,CAChD,2BACA,wDACA,OAAO,KAAK,UAAUH,EAAQ,QAAQ,CAAC,EACzC,EAAGA,CAAO,EAGZ,GAAGA,EAAQ,MAAQ,QAAaA,EAAQ,MAAQ,MAAQA,EAAQ,MAAQ,GACtEA,EAAQ,IAAM,WACPA,EAAQ,MAAQ,GACvB,MAAM,IAAIG,EAAS,yBAA0B,CAC3C,sBAAuB,oBACvB,OAAO,KAAK,UAAUH,EAAQ,GAAG,CAAC,EACpC,EAAGA,CAAO,EAIZ,GADAA,EAAQ,cAAgB,KACrBA,EAAQ,OAAS,QAAaA,EAAQ,OAAS,MAAQA,EAAQ,OAAS,IAASA,EAAQ,OAAS,GACnGA,EAAQ,KAAO,eACR,OAAOA,EAAQ,MAAS,WAC/BA,EAAQ,cAAgBA,EAAQ,KAChCA,EAAQ,KAAO,WACRA,EAAQ,OAAS,GACxB,MAAM,IAAIG,EAAS,0BAA2B,CAC5C,uBAAwB,mCACxB,OAAO,KAAK,UAAUH,EAAQ,IAAI,CAAC,EACrC,EAAGA,CAAO,EAGZ,GAAGA,EAAQ,YAAc,QAAaA,EAAQ,YAAc,MAAQA,EAAQ,YAAc,IAASA,EAAQ,YAAc,GACvHA,EAAQ,UAAY,WACbA,EAAQ,YAAc,GAC7BA,EAAQ,UAAY,SAASI,EAAM,CACjC,IAAMC,EAAO,KAAK,MAAMD,CAAK,EAC7B,OAAQ,MAAMC,CAAI,EAAqBD,EAAjB,IAAI,KAAKC,CAAI,CACrC,UACQ,OAAOL,EAAQ,WAAc,WACrC,MAAM,IAAIG,EAAS,+BAAgC,CACjD,4BAA6B,wCAC7B,OAAO,KAAK,UAAUH,EAAQ,SAAS,CAAC,EAC1C,EAAGA,CAAO,EAIZ,GADAA,EAAQ,0BAA4B,KACjCA,EAAQ,UAAY,GAErBA,EAAQ,0BAA4B,eAC7B,OAAOA,EAAQ,SAAY,WAClCA,EAAQ,0BAA4BA,EAAQ,QAC5CA,EAAQ,QAAU,WACX,MAAM,QAAQA,EAAQ,OAAO,EACpCA,EAAQ,QAAUM,GAAwBN,EAAQ,OAAO,UAClDA,EAAQ,UAAY,QAAaA,EAAQ,UAAY,MAAQA,EAAQ,UAAY,GACxFA,EAAQ,QAAU,OAElB,OAAM,IAAIG,EAAS,6BAA8B,CAC/C,0BACA,uCACA,OAAO,KAAK,UAAUH,EAAQ,OAAO,CAAC,EACxC,EAAGA,CAAO,EAGZ,GAAGA,EAAQ,wBAA0B,QAAaA,EAAQ,wBAA0B,MAAQA,EAAQ,wBAA0B,GAC5HA,EAAQ,sBAAwB,OAC5B,IAAGA,EAAQ,wBAA0B,GACzC,MAAM,IAAIG,EAAS,2CAA4C,CAC7D,wCACA,qBACA,OAAO,KAAK,UAAUH,EAAQ,qBAAqB,CAAC,EACtD,EAAGA,CAAO,EACN,GAAGA,EAAQ,UAAY,GAC3B,MAAM,IAAIG,EAAS,2CAA4C,CAC7D,wCACA,uCACF,EAAGH,CAAO,EAGZ,GAAGA,EAAQ,UAAY,QAAaA,EAAQ,UAAY,MAAQA,EAAQ,UAAY,IAASA,EAAQ,UAAY,GAC/GA,EAAQ,QAAU,aAEf,OAAOA,EAAQ,SAAY,WAC5BA,EAAQ,QAAUO,EAAO,KAAKP,EAAQ,QAASA,EAAQ,QAAQ,GAE9D,CAACO,EAAO,SAASP,EAAQ,OAAO,EACjC,MAAM,IAAIG,EAAS,6BAA8B,CAC/C,0BACA,wCACA,OAAO,KAAK,UAAUH,EAAQ,OAAO,CAAC,EACxC,EAAGA,CAAO,EAId,GAAGA,EAAQ,mBAAqB,QAAaA,EAAQ,mBAAqB,MAAQA,EAAQ,mBAAqB,GAC7GA,EAAQ,iBAAmB,WACpBA,EAAQ,mBAAqB,GACpC,MAAM,IAAIG,EAAS,6BAA8B,CAC/C,mCACA,2BACA,OAAO,KAAK,UAAUH,EAAQ,gBAAgB,CAAC,EACjD,EAAGA,CAAO,EAGZ,IAAMQ,EAAiB,KAAK,UAAUR,EAAQ,SAAS,EAEvD,GADI,MAAM,QAAQA,EAAQ,SAAS,IAAGA,EAAQ,UAAY,CAACA,EAAQ,SAAS,GACzEA,EAAQ,UAAU,SAAW,EAC9B,MAAM,IAAIG,EAAS,+BAAgC,CACjD,4BACA,4EACA,OAAOK,CAAc,EACvB,EAAGR,CAAO,EA0BZ,GAxBAA,EAAQ,UAAYA,EAAQ,UAAU,IAAI,SAASS,EAAU,CAC3D,GAA8BA,GAAc,MAAQA,IAAc,GAChE,OAAOF,EAAO,KAAK,IAAKP,EAAQ,QAAQ,EAK1C,GAHG,OAAOS,GAAc,WACtBA,EAAYF,EAAO,KAAKE,EAAWT,EAAQ,QAAQ,GAElD,CAACO,EAAO,SAASE,CAAS,GAAKA,EAAU,SAAW,EACrD,MAAM,IAAIN,EAAS,+BAAgC,CACjD,4BACA,4EACA,OAAOK,CAAc,EACvB,EAAGR,CAAO,EAEZ,OAAOS,CACT,CAAC,EAEET,EAAQ,SAAW,QAAaA,EAAQ,SAAW,GACpDA,EAAQ,OAASO,EAAO,KAAK,IAAKP,EAAQ,QAAQ,EAC3C,OAAOA,EAAQ,QAAW,SACjCA,EAAQ,OAASO,EAAO,KAAKP,EAAQ,OAAQA,EAAQ,QAAQ,GACrDA,EAAQ,SAAW,MAAQA,EAAQ,SAAW,MACtDA,EAAQ,OAAS,MAEhBA,EAAQ,SAAW,MACjB,CAACO,EAAO,SAASP,EAAQ,MAAM,EAChC,MAAM,IAAI,MAAM,uEAAuE,KAAK,UAAUA,EAAQ,MAAM,CAAC,EAAE,EAI3H,GAAGA,EAAQ,OAAS,QAAaA,EAAQ,OAAS,KAChDA,EAAQ,KAAO,UAEZ,OAAOA,EAAQ,MAAS,UAAY,MAAM,KAAKA,EAAQ,IAAI,IAC5DA,EAAQ,KAAO,SAASA,EAAQ,IAAI,GAEnC,OAAO,UAAUA,EAAQ,IAAI,GAC9B,GAAGA,EAAQ,KAAO,EAChB,MAAM,IAAI,MAAM,wDAAwD,KAAK,UAAUD,EAAK,IAAI,CAAC,EAAE,MAGrG,OAAM,IAAI,MAAM,gDAAgD,KAAK,UAAUC,EAAQ,IAAI,CAAC,EAAE,EAIlG,GAAGA,EAAQ,YAAc,QAAaA,EAAQ,YAAc,KAC1DA,EAAQ,UAAY,UAEjB,OAAOA,EAAQ,WAAc,UAAY,MAAM,KAAKA,EAAQ,SAAS,IACtEA,EAAQ,UAAY,SAASA,EAAQ,SAAS,GAE7C,OAAO,UAAUA,EAAQ,SAAS,GACnC,GAAGA,EAAQ,WAAa,EACtB,MAAM,IAAI,MAAM,4EAA4E,KAAK,UAAUD,EAAK,SAAS,CAAC,EAAE,MAG9H,OAAM,IAAI,MAAM,qDAAqD,KAAK,UAAUA,EAAK,SAAS,CAAC,EAAE,EAIzG,GAAGC,EAAQ,yBAA2B,QAAaA,EAAQ,yBAA2B,KACpFA,EAAQ,uBAAyB,WAC1B,OAAOA,EAAQ,wBAA2B,SACjDA,EAAQ,uBAAyB,KAAK,MAAMA,EAAQ,sBAAsB,EACvEA,EAAQ,yBAA2B,IACpCA,EAAQ,uBAAyB,YAE5B,OAAOA,EAAQ,wBAA2B,UACjD,MAAM,IAAIG,EAAS,4CAA6C,CAC9D,2CACA,mDACA,OAAO,KAAK,UAAUH,EAAQ,sBAAsB,CAAC,EACvD,EAAGA,CAAO,EAEZ,GAAGA,EAAQ,yBAA2B,IAAQA,EAAQ,UAAY,GAChE,MAAM,IAAIG,EAAS,8CAA+C,CAChE,sCACA,iDACF,EAAGH,CAAO,EAGZ,GAAGA,EAAQ,OAAS,QAAaA,EAAQ,OAAS,MAAQA,EAAQ,OAAS,GACzEA,EAAQ,KAAO,WACRA,EAAQ,OAAS,GACxB,MAAM,IAAI,MAAM,0CAA0C,KAAK,UAAUA,EAAQ,IAAI,CAAC,EAAE,EAG1F,GAAGA,EAAQ,kBAAoB,QAAaA,EAAQ,kBAAoB,MAAQA,EAAQ,kBAAoB,GAC1GA,EAAQ,gBAAkB,UACnB,SAAO,UAAUA,EAAQ,eAAe,GAAKA,EAAQ,iBAAmB,GAE3E,GAAG,OAAOA,EAAQ,iBAAoB,UAAY,MAAM,KAAKA,EAAQ,eAAe,EACxFA,EAAQ,gBAAkB,SAASA,EAAQ,eAAe,MAE1D,OAAM,IAAI,MAAM,mEAAmE,KAAK,UAAUA,EAAQ,eAAe,CAAC,EAAE,EAG9H,GAAGA,EAAQ,UAAY,QAAaA,EAAQ,UAAY,MAAQA,EAAQ,UAAY,GAClFA,EAAQ,QAAU,eACXO,EAAO,SAASP,EAAQ,OAAO,EAAE,CACxC,GAAGA,EAAQ,QAAQ,SAAW,EAC5B,MAAM,IAAI,MAAM,oDAAoD,EAEnEA,EAAQ,WAAa,OAGtBA,EAAQ,QAAUA,EAAQ,QAAQ,SAASA,EAAQ,QAAQ,EAE/D,SAAS,OAAOA,EAAQ,SAAY,UAClC,GAAGA,EAAQ,QAAQ,SAAW,EAC5B,MAAM,IAAI,MAAM,oDAAoD,UAG/D,OAAOA,EAAQ,SAAY,SAMlC,MAAM,IAAI,MAAM,6DAA6DA,EAAQ,OAAO,EAAE,EAEhG,GAAGA,EAAQ,UAAY,QACrB,GAAG,OAAOA,EAAQ,SAAY,UAC5B,GAAGA,EAAQ,UAAY,GACrB,MAAM,MAAM,wFAAwF,UAGnGA,EAAQ,UAAY,GACrB,MAAM,MAAM,uFAAuF,EAKzG,GAAGA,EAAQ,YAAc,QAAaA,EAAQ,YAAc,KAC1DA,EAAQ,UAAY,eACb,OAAOA,EAAQ,WAAc,WACpC,MAAM,IAAIG,EAAS,+BAAgC,CACjD,8BACA,qBACA,OAAO,KAAK,UAAUH,EAAQ,SAAS,CAAC,EAC1C,EAAGA,CAAO,EAGZ,GAAGA,EAAQ,QAAU,MAAQA,EAAQ,QAAU,IAASA,EAAQ,QAAU,GACxEA,EAAQ,MAAQ,aAEbA,EAAQ,QAAU,QAAaA,EAAQ,QAAU,GAClDA,EAAQ,MAAQO,EAAO,KAAK,IAAKP,EAAQ,QAAQ,EAC1C,OAAOA,EAAQ,OAAU,WAChCA,EAAQ,MAAQO,EAAO,KAAKP,EAAQ,MAAOA,EAAQ,QAAQ,GAE1D,CAACO,EAAO,SAASP,EAAQ,KAAK,EAC/B,MAAM,IAAI,MAAM,2DAA2D,KAAK,UAAUA,EAAQ,KAAK,CAAC,EAAE,EAI9G,GAAGA,EAAQ,MAAQ,QAAaA,EAAQ,MAAQ,MAAQA,EAAQ,MAAQ,GACtEA,EAAQ,IAAM,WACPA,EAAQ,MAAQ,GACvB,MAAM,IAAI,MAAM,yCAAyC,KAAK,UAAUA,EAAQ,GAAG,CAAC,EAAE,EAGxF,GAAGA,EAAQ,mBAAqB,OAC9BA,EAAQ,iBAAmB,CAAC,UACrB,OAAOA,EAAQ,kBAAqB,UAAYO,EAAO,SAASP,EAAQ,gBAAgB,EAAE,CACjG,GAAGA,EAAQ,iBAAiB,SAAW,EACrC,MAAM,IAAIG,EAAS,sCAAuC,CACxD,qCACA,8CACA,OAAO,KAAK,UAAUH,EAAQ,gBAAgB,CAAC,EACjD,EAAGA,CAAO,EAEZA,EAAQ,iBAAmB,CAACA,EAAQ,gBAAgB,CACtD,SAAS,CAAC,MAAM,QAAQA,EAAQ,gBAAgB,EAC9C,MAAM,IAAIG,EAAS,sCAAuC,CACxD,qCACA,8DACA,OAAO,KAAK,UAAUH,EAAQ,gBAAgB,CAAC,EACjD,EAAGA,CAAO,EAwBZ,GAtBAA,EAAQ,iBAAmBA,EAAQ,iBAAiB,IAAI,SAASU,EAAIC,EAAE,CACrE,GAAG,OAAOD,GAAO,UAAY,CAAEH,EAAO,SAASG,CAAE,EAC/C,MAAM,IAAIP,EAAS,sCAAuC,CACxD,qCACA,6DACA,YAAYQ,CAAC,IACb,OAAO,KAAK,UAAUD,CAAE,CAAC,EAC3B,EAAGV,CAAO,EACN,GAAGU,EAAG,SAAW,EACrB,MAAM,IAAIP,EAAS,sCAAuC,CACxD,qCACA,6CACA,YAAYQ,CAAC,IACb,OAAO,KAAK,UAAUD,CAAE,CAAC,EAC3B,EAAGV,CAAO,EAEZ,OAAG,OAAOU,GAAO,WACfA,EAAKH,EAAO,KAAKG,EAAIV,EAAQ,QAAQ,GAEhCU,CACT,CAAC,EAEE,OAAOV,EAAQ,oBAAuB,UAEnC,GAAGA,EAAQ,qBAAuB,QAAaA,EAAQ,qBAAuB,KAClFA,EAAQ,mBAAqB,OAE7B,OAAM,IAAI,MAAM,6DAA6D,KAAK,UAAUA,EAAQ,kBAAkB,CAAC,EAAE,EAE3H,GAAG,OAAOA,EAAQ,yBAA4B,UAExC,GAAGA,EAAQ,0BAA4B,QAAaA,EAAQ,0BAA4B,KAC5FA,EAAQ,wBAA0B,OAElC,OAAM,IAAI,MAAM,kEAAkE,KAAK,UAAUA,EAAQ,uBAAuB,CAAC,EAAE,EAErI,GAAG,OAAOA,EAAQ,yBAA4B,UAExC,GAAGA,EAAQ,0BAA4B,QAAaA,EAAQ,0BAA4B,KAC5FA,EAAQ,wBAA0B,OAElC,OAAM,IAAI,MAAM,kEAAkE,KAAK,UAAUA,EAAQ,uBAAuB,CAAC,EAAE,EAGrI,GAAG,OAAOA,EAAQ,cAAiB,UAE7B,GAAGA,EAAQ,eAAiB,QAAaA,EAAQ,eAAiB,KACtEA,EAAQ,aAAe,OAEvB,OAAM,IAAI,MAAM,uDAAuD,KAAK,UAAUA,EAAQ,YAAY,CAAC,EAAE,EAG/G,GAAG,OAAOA,EAAQ,kBAAqB,UAEjC,GAAGA,EAAQ,mBAAqB,QAAaA,EAAQ,mBAAqB,KAC9EA,EAAQ,iBAAmB,OAE3B,OAAM,IAAI,MAAM,2DAA2D,KAAK,UAAUA,EAAQ,gBAAgB,CAAC,EAAE,EAGvH,GAAG,OAAOA,EAAQ,gCAAmC,UAE/C,GAAGA,EAAQ,iCAAmC,QAAaA,EAAQ,iCAAmC,KAC1GA,EAAQ,+BAAiC,OAEzC,OAAM,IAAI,MAAM,yEAAyE,KAAK,UAAUA,EAAQ,8BAA8B,CAAC,EAAE,EAGnJ,GAAG,OAAOA,EAAQ,yBAA4B,UAExC,GAAGA,EAAQ,0BAA4B,QAAaA,EAAQ,0BAA4B,KAC5FA,EAAQ,wBAA0B,OAElC,OAAM,IAAI,MAAM,kEAAkE,KAAK,UAAUA,EAAQ,uBAAuB,CAAC,EAAE,EAGrI,GAAGA,EAAQ,QAAU,QAAaA,EAAQ,QAAU,MAAQA,EAAQ,QAAU,GAC5EA,EAAQ,MAAQ,WACTA,EAAQ,QAAU,GACzB,MAAM,IAAI,MAAM,gDAAgD,KAAK,UAAUA,EAAQ,KAAK,CAAC,EAAE,EAGjG,GAAGA,EAAQ,QAAU,QAAaA,EAAQ,QAAU,MAAQA,EAAQ,QAAU,GAC5EA,EAAQ,MAAQ,WACTA,EAAQ,QAAU,GACzB,MAAM,IAAI,MAAM,gDAAgD,KAAK,UAAUA,EAAQ,KAAK,CAAC,EAAE,EAGjG,GAAGA,EAAQ,OAAS,QAAaA,EAAQ,OAAS,MAAQA,EAAQ,OAAS,GACzEA,EAAQ,KAAO,WACRA,EAAQ,OAAS,GACxB,MAAM,IAAI,MAAM,+CAA+C,KAAK,UAAUA,EAAQ,IAAI,CAAC,EAAE,EAc/F,GAXGA,EAAQ,OAAS,IAAQD,EAAK,QAAU,GACzCC,EAAQ,MAAQ,GACTA,EAAQ,QAAU,KACzBA,EAAQ,MAAQ,IAEfA,EAAQ,OAAS,IAAQD,EAAK,QAAU,GACzCC,EAAQ,MAAQ,GACTA,EAAQ,QAAU,KACzBA,EAAQ,MAAQ,IAGfA,EAAQ,KAAO,QAAaA,EAAQ,KAAO,KAC5CA,EAAQ,GAAK,WAEV,OAAOA,EAAQ,IAAO,UAAY,MAAM,KAAKA,EAAQ,EAAE,IACxDA,EAAQ,GAAK,SAASA,EAAQ,EAAE,GAE/B,OAAO,UAAUA,EAAQ,EAAE,GAC5B,GAAGA,EAAQ,IAAM,EACf,MAAM,IAAI,MAAM,qEAAqE,KAAK,UAAUD,EAAK,EAAE,CAAC,EAAE,MAGhH,OAAM,IAAI,MAAM,8CAA8C,KAAK,UAAUA,EAAK,EAAE,CAAC,EAAE,EAI3F,GAAGC,EAAQ,UAAY,QAAaA,EAAQ,UAAY,KACtDA,EAAQ,QAAU,WAEf,OAAOA,EAAQ,SAAY,UAAY,MAAM,KAAKA,EAAQ,OAAO,IAClEA,EAAQ,QAAU,SAASA,EAAQ,OAAO,GAEzC,OAAO,UAAUA,EAAQ,OAAO,GACjC,GAAGA,EAAQ,SAAW,EACpB,MAAM,IAAI,MAAM,0EAA0E,KAAK,UAAUD,EAAK,OAAO,CAAC,EAAE,MAG1H,OAAM,IAAI,MAAM,mDAAmD,KAAK,UAAUA,EAAK,OAAO,CAAC,EAAE,EAGrG,OAAOC,CACT,ECvbA,IAAMY,GAAgB,SAASC,EAAO,CACpC,OAAOA,EAAO,MAAOC,GAAUA,GAAS,MAAQA,EAAM,UAAYA,EAAM,SAAS,EAAE,KAAK,IAAM,EAAE,CAClG,EAEMC,GAAK,GACLC,GAAK,GAELC,GAAO,CAKX,KAAQC,EAAO,KAAK,CAAC,IAAK,IAAK,GAAG,CAAC,EAInC,QAAWA,EAAO,KAAK,CAAC,IAAK,GAAG,CAAC,CACnC,EAEMC,GAAY,SAASC,EAAmB,CAAC,EAAG,CAChD,IAAMC,EAAO,CACX,MAAO,EACP,cAAe,EACf,YAAa,EACb,qBAAsB,EACtB,MAAO,EACP,QAAS,CACX,EACMC,EAAUC,GAAkBH,CAAgB,EAClD,MAAO,CACL,KAAMC,EACN,iBAAkBD,EAClB,QAASE,EACT,MAAOE,GAAWF,CAAO,EACzB,eAAgB,SAASG,EAAGC,EAAQC,EAAI,CACtC,GAAGA,EAAK,MAAO,GACf,GAAM,CAAC,SAAAC,EAAU,OAAAC,EAAQ,MAAAC,CAAK,EAAI,KAAK,QACjC,CAAC,QAAAC,EAAS,iBAAAC,EAAkB,yBAAAC,CAAwB,EAAI,KAAK,MAC7DC,EAAgBR,EAASD,EAAI,EAC7BU,EAAiB,KAAK,IAC1BH,EAOAC,IAA6B,EAAIf,EAAO,KAAK;AAAA,EAAQU,CAAQ,EAAE,OAASK,EAExEF,GAAYF,IAAW,KAAO,EAAIA,EAAO,QAAUC,EAAM,OAAU,EAEnEC,EAAWD,EAAM,OAASG,EAA4B,CACxD,EACA,OAAOC,EAAgBC,CACzB,EAEA,MAAO,SAASC,EAAST,EAAKU,EAAMC,EAAM,CACxC,GAAM,CAAC,IAAAC,EAAK,iBAAAC,EAAkB,SAAAZ,EAAU,UAAAa,EAAW,MAAAC,EAAO,gBAAAC,EAAgB,IAAAC,EAAK,aAAAC,EAAc,MAAAC,EAAO,iBAAAC,EAAkB,GAAAC,EAAI,QAAAC,CAAO,EAAI,KAAK,QACtI,CAAC,QAAAC,EAAS,OAAArB,EAAQ,MAAAC,EAAO,iBAAAqB,CAAgB,EAAI,KAAK,QAChD,CAAC,WAAAC,GAAY,YAAAC,GAAa,UAAAC,GAAW,cAAAC,EAAa,EAAI,KAAK,MAC7DC,EACJ,GAAGH,KAAgB,OACjB,GAAGjB,IAAY,OAAU,CAEvBE,EAAM,EACN,MACF,MACEkB,EAAMpB,OAEDiB,KAAgB,QAAajB,IAAY,OAChDoB,EAAMH,GAENG,EAAMtC,EAAO,OAAO,CAACmC,GAAajB,CAAO,CAAC,EAG5C,GAAGgB,KAAe,GAChB,GAAGb,IAAQ,GACT,KAAK,MAAM,WAAa,WACjBiB,EAAI,OAAS,GAEpB,GAAG7B,IAAQ,GAAM,CAEf,KAAK,MAAM,YAAc6B,EACzB,MACF,MACG,CACH,QAAU5B,KAAYX,GACpB,GAAGA,GAAKW,CAAQ,EAAE,QAAQ4B,EAAK,EAAGvC,GAAKW,CAAQ,EAAE,MAAM,IAAM,EAAE,CAE7D,IAAM6B,EAAYxC,GAAKW,CAAQ,EAAE,OACjC,KAAK,MAAM,eAAiB6B,EAC5BD,EAAMA,EAAI,MAAMC,CAAS,EAEzB,KAAK,QAAUlC,GAAkB,CAAC,GAAG,KAAK,iBAAkB,SAAUK,CAAQ,CAAC,EAE9E,CAAC,QAAAsB,EAAS,OAAArB,EAAQ,MAAAC,CAAM,EAAI,KAAK,QAClC,KACF,CAEF,KAAK,MAAM,WAAa,EAC1B,CAEF,IAAMJ,GAAS8B,EAAI,OACfE,EACJ,IAAIA,EAAM,EAAGA,EAAMhC,IAGd,MAAK,eAAegC,EAAKhC,GAAQC,CAAG,EAHd+B,IAAM,CAU/B,GAJG,KAAK,MAAM,kBAAoB,KAChC,KAAK,KAAK,QACV,KAAK,MAAM,gBAAkB,IAE5BT,IAAY,IAAM,KAAK,KAAK,MAAQA,EAAQ,CAC7C,KAAK,MAAM,KAAO,GAClBX,EAAM,EACN,MACF,CAEG,KAAK,MAAM,UAAY,IAASa,EAAiB,SAAW,GAC/B,KAAK,8BAA8BK,EAAKE,CAAG,IAEvEP,EAAmB,KAAK,QAAQ,kBAGpC,IAAMQ,EAAMH,EAAIE,CAAG,EASnB,GARGd,IAAQ,IACTU,GAAU,OAAOK,CAAG,GAElBA,IAAQ5C,IAAM4C,IAAQ3C,KAAO,KAAK,MAAM,kBAAoB,KAC9D,KAAK,MAAM,gBAAkB,IAI5B,KAAK,MAAM,WAAa,GACzB,KAAK,MAAM,SAAW,OACnB,CAIH,GAAGa,IAAW,MAAQ,KAAK,MAAM,UAAY,IAAQ,KAAK,WAAW2B,EAAKE,EAAKC,CAAG,GAAKD,EAAM7B,EAAO,OAASH,GAC3G,GAAG6B,IACD,GAAG,KAAK,UAAUC,EAAKE,EAAI7B,EAAO,MAAM,EAAE,CACxC,KAAK,MAAM,SAAW,GACtB6B,GAAO7B,EAAO,OAAS,EACvB,QACF,MACG,CACH,KAAK,MAAM,SAAW,GACtB6B,GAAO7B,EAAO,OAAS,EACvB,QACF,CAIF,GAAG,KAAK,MAAM,aAAe,IAAS,KAAK,UAAU2B,EAAKE,CAAG,EAC3D,GAAG,KAAK,MAAM,UAAY,GAAK,CAC7B,IAAME,EAAUJ,EAAIE,EAAI5B,EAAM,MAAM,EAC9B+B,EAAoBf,GAAS,KAAK,iBAAiBU,EAAKE,EAAI5B,EAAM,MAAM,EACxEgC,EAAmBZ,IAAY,MAAQ,KAAK,eAAeA,EAASM,EAAKE,EAAI5B,EAAM,OAAQ8B,CAAO,EAClGG,EAAqB,KAAK,cAAcP,EAAKE,EAAI5B,EAAM,OAAQ8B,CAAO,EACtEI,EAA2Bb,EAAiB,SAAW,EAAI,KAAK,8BAA8BK,EAAKE,EAAI5B,EAAM,MAAM,EAAI,KAAK,oBAAoB8B,EAASJ,EAAKE,EAAI5B,EAAM,MAAM,EAGpL,GAAGD,IAAW,MAAQ,KAAK,WAAW2B,EAAKE,EAAKC,CAAG,GAAK,KAAK,UAAUH,EAAKE,EAAM7B,EAAO,MAAM,EAC7F6B,GAAO7B,EAAO,OAAS,UAChB,CAAC+B,GAAWG,GAAsBC,GAA4BF,GAAoBD,EAAkB,CAC3G,KAAK,MAAM,QAAU,GACrB,KAAK,MAAM,WAAa,GACxBH,GAAO5B,EAAM,OAAS,EACtB,QACF,SAASe,IAAiB,GAAM,CAC9B,IAAMoB,EAAM,KAAK,QACf,IAAIC,EAAS,4BAA6B,CACxC,yBACA,QAAQ,OAAO,aAAaN,CAAO,CAAC,IACpC,WAAW,KAAK,KAAK,KAAK,GAC1B,6DACA,2BACF,EAAG,KAAK,QAAS,KAAK,YAAY,CAAC,CACrC,EACA,GAAGK,IAAQ,OAAW,OAAOA,CAC/B,MACE,KAAK,MAAM,QAAU,GACrB,KAAK,MAAM,WAAa,GACxB,KAAK,MAAM,MAAM,QAAQnC,CAAK,EAC9B4B,GAAO5B,EAAM,OAAS,CAE1B,SACK,KAAK,MAAM,MAAM,SAAW,GAE7B,GAAGe,IAAiB,GAAM,CACxB,IAAMxB,EAAO,KAAK,YAAY,EACxBkB,EAAM,OAAO,KAAKtB,EAAI,EAAE,IAAIkD,GAAKlD,GAAKkD,CAAC,EAAE,OAAO,KAAK,MAAM,MAAM,SAAS,CAAC,EAAIA,EAAI,EAAK,EAAE,OAAO,OAAO,EAAE,CAAC,EAC3GF,EAAM,KAAK,QACf,IAAIC,EAAS,wBAAyB,CACpC,yBACA,6BAA6B,KAAK,UAAU7C,EAAK,MAAM,CAAC,YAAYA,EAAK,KAAK,cAAc,KAAK,UAAU,KAAK,MAAM,MAAM,SAASO,CAAQ,CAAC,CAAC,GAC/IW,EAAM,IAAIA,CAAG,QAAU,MACzB,EAAG,KAAK,QAASlB,EAAM,CACrB,MAAO,KAAK,MAAM,KACpB,CAAC,CACH,EACA,GAAG4C,IAAQ,OAAW,OAAOA,CAC/B,MACG,CACH,KAAK,MAAM,QAAU,GACrBP,GAAO5B,EAAM,OAAS,EACtB,QACF,CAGJ,GAAG,KAAK,MAAM,UAAY,GAAM,CAC9B,IAAMsC,EAAwB,KAAK,oBAAoBT,EAAKH,EAAKE,CAAG,EACpE,GAAGU,IAA0B,EAAE,CAG7B,GADwB,KAAK,MAAM,YAAe,KAAK,MAAM,aAAe,IAAS,KAAK,MAAM,OAAO,SAAW,GAAK,KAAK,MAAM,MAAM,SAAW,EAEjJ,KAAK,KAAK,oBAEP,CAEH,GAAG,KAAK,MAAM,UAAY,IAAS,KAAK,KAAK,OAAS,KAAK,MAAM,kBAAoB,GAAO,EAAG,IAAM3B,EAAU,CAC7G,KAAK,MAAM,QAAU,GACrB,KAAK,aAAa,EAClB,KAAK,cAAc,EACnBiB,GAAOU,EAAwB,EAC/B,QACF,CAEA,GAAGrB,IAAqB,IAAQ,KAAK,MAAM,aAAe,IAAS,KAAK,MAAM,OAAO,SAAW,GAAK,KAAK,MAAM,MAAM,SAAW,EAAE,CACjI,KAAK,KAAK,cACVW,GAAOU,EAAwB,EAC/B,QACF,CACA,KAAK,KAAK,MAAQ,KAAK,MAAM,cAAgBV,EAC7C,IAAMW,EAAW,KAAK,UAAU,EAChC,GAAGA,IAAa,OAAW,OAAOA,EAClC,KAAK,KAAK,MAAQ,KAAK,MAAM,cAAgBX,EAAMU,EACnD,IAAME,EAAY,KAAK,WAAWjC,CAAI,EACtC,GAAGiC,IAAc,OAAW,OAAOA,EACnC,GAAGtB,IAAO,IAAM,KAAK,KAAK,SAAWA,EAAG,CACtC,KAAK,MAAM,KAAO,GAClBV,EAAM,EACN,MACF,CACF,CACA,KAAK,MAAM,WAAa,GACxBoB,GAAOU,EAAwB,EAC/B,QACF,CACA,GAAG,KAAK,MAAM,WACZ,SAGF,IADqBlB,IAAY,KAAO,EAAI,KAAK,eAAeA,EAASM,EAAKE,EAAKC,CAAG,KAClE,IAAMnB,IAAqB,IAAS,KAAK,MAAM,MAAM,SAAW,GAAG,CACrF,KAAK,MAAM,WAAa,GACxB,QACF,CACA,IAAM+B,EAAkB,KAAK,cAAcf,EAAKE,EAAKC,CAAG,EACxD,GAAGY,IAAoB,EAAE,CACvB,KAAK,KAAK,MAAQ,KAAK,MAAM,cAAgBb,EAC7C,IAAMW,EAAW,KAAK,UAAU,EAChC,GAAGA,IAAa,OAAW,OAAOA,EAClCX,GAAOa,EAAkB,EACzB,QACF,CACF,CACF,CACA,GAAG,KAAK,MAAM,aAAe,IACxB5B,IAAoB,GAAK,KAAK,MAAM,cAAgB,KAAK,MAAM,MAAM,OAASA,EAC/E,OAAO,KAAK,QACV,IAAIuB,EAAS,sBAAuB,CAClC,mBACA,sDACA,MAAMvB,CAAe,GACrB,WAAW,KAAK,KAAK,KAAK,EAC5B,EAAG,KAAK,QAAS,KAAK,YAAY,CAAC,CACrC,EAGJ,IAAM6B,EAAU9B,IAAU,IAAS,KAAK,MAAM,UAAY,IAAQ,KAAK,MAAM,MAAM,SAAW,GAAK,CAAC,KAAK,iBAAiBc,EAAKE,CAAG,EAE5He,GAAU3B,IAAU,IAAS,KAAK,MAAM,aAAe,GAC7D,GAAG0B,IAAY,IAAQC,KAAY,GACjC,KAAK,MAAM,MAAM,OAAOd,CAAG,MACvB,IAAGb,IAAU,IAAQ,CAAC,KAAK,iBAAiBU,EAAKE,CAAG,EACxD,OAAO,KAAK,QACV,IAAIQ,EAAS,4CAA6C,CACxD,yBACA,sCACA,WAAW,KAAK,KAAK,KAAK,EAC5B,EAAG,KAAK,QAAS,KAAK,YAAY,CAAC,CACrC,EAEGM,IAAY,KACbd,GAAO,KAAK,iBAAiBF,EAAKE,CAAG,EAAI,GAE3C,SAEJ,CACA,GAAG/B,IAAQ,GAET,GAAG,KAAK,MAAM,UAAY,GAAK,CAC7B,IAAMsC,EAAM,KAAK,QACf,IAAIC,EAAS,uBAAwB,CACnC,oBACA,yDAAyD,KAAK,KAAK,KAAK,EAC1E,EAAG,KAAK,QAAS,KAAK,YAAY,CAAC,CACrC,EACA,GAAGD,IAAQ,OAAW,OAAOA,CAC/B,SAEK,KAAK,MAAM,aAAe,IAAQ,KAAK,MAAM,OAAO,SAAW,GAAK,KAAK,MAAM,MAAM,SAAW,EAAE,CACnG,KAAK,KAAK,MAAQ,KAAK,MAAM,cAAgBP,EAC7C,IAAMW,EAAW,KAAK,UAAU,EAChC,GAAGA,IAAa,OAAW,OAAOA,EAClC,IAAMC,EAAY,KAAK,WAAWjC,CAAI,EACtC,GAAGiC,IAAc,OAAW,OAAOA,CACrC,MAAS,KAAK,MAAM,kBAAoB,GACtC,KAAK,KAAK,cACH,KAAK,MAAM,aAAe,IACjC,KAAK,KAAK,qBAId,KAAK,MAAM,eAAiBZ,EAC5B,KAAK,MAAM,YAAcF,EAAI,MAAME,CAAG,EAErC,KAAK,MAAM,kBAAoB,KAChC,KAAK,KAAK,QACV,KAAK,MAAM,gBAAkB,GAEjC,EACA,WAAY,SAASrB,EAAK,CACxB,GAAM,CAAC,QAAAqC,EAAS,sBAAAC,EAAuB,SAAA/C,EAAU,KAAAP,EAAM,KAAAuD,EAAM,mBAAAC,EAAoB,wBAAAC,EAAyB,wBAAAC,EAAyB,IAAAnC,EAAK,+BAAAoC,CAA8B,EAAI,KAAK,QACzK,CAAC,QAAAC,EAAS,OAAApE,CAAM,EAAI,KAAK,MAC/B,GAAGoE,IAAY,GACb,OAAO,KAAK,cAAc,EAG5B,IAAMC,EAAerE,EAAO,OAC5B,GAAG6D,IAAY,GAAK,CAClB,GAAGM,IAAmC,IAAQpE,GAAcC,CAAM,EAAE,CAClE,KAAK,cAAc,EACnB,MACF,CACA,OAAO,KAAK,qBAAqBA,CAAM,CACzC,CAIA,GAHG6D,IAAY,IAAS,KAAK,KAAK,UAAY,IAC5C,KAAK,MAAM,qBAAuBQ,GAEjCA,IAAiB,KAAK,MAAM,qBAAqB,CAClD,IAAMjB,EAAMS,IAAY,GACtB,IAAIR,EAAS,wCAAyC,CACpD,yBACA,UAAU,KAAK,MAAM,oBAAoB,IACzC,OAAOgB,CAAY,YAAY,KAAK,KAAK,KAAK,EAChD,EAAG,KAAK,QAAS,KAAK,YAAY,EAAG,CACnC,OAAQrE,CACV,CAAC,EAED,IAAIqD,EAAS,kCAAmC,CAC9C,yBACA,qBAAqBQ,EAAQ,MAAM,IACnC,OAAOQ,CAAY,YAAY,KAAK,KAAK,KAAK,EAChD,EAAG,KAAK,QAAS,KAAK,YAAY,EAAG,CACnC,OAAQrE,CACV,CAAC,EACH,GAAGgE,IAAuB,IACvBC,IAA4B,IAAQI,EAAe,KAAK,MAAM,sBAC9DH,IAA4B,IAAQG,EAAe,KAAK,MAAM,qBAC/D,KAAK,KAAK,uBACV,KAAK,MAAM,MAAQjB,MAEhB,CACH,IAAMkB,EAAW,KAAK,QAAQlB,CAAG,EACjC,GAAGkB,EAAU,OAAOA,CACtB,CACF,CACA,GAAGH,IAAmC,IAAQpE,GAAcC,CAAM,EAAE,CAClE,KAAK,cAAc,EACnB,MACF,CACA,GAAG,KAAK,MAAM,iBAAmB,GAAK,CACpC,KAAK,cAAc,EACnB,KAAK,MAAM,eAAiB,GAC5B,MACF,CAEA,GADA,KAAK,KAAK,UACP+D,IAAS,GAAK,KAAK,KAAK,SAAWA,EAAK,CACzC,GAAM,CAAC,QAAAQ,CAAO,EAAI,KAAK,QAEvB,GAAGV,IAAY,GAAM,CACnB,IAAMW,EAAM,CAAC,EAEb,QAAQ5D,EAAI,EAAG6D,EAAIzE,EAAO,OAAQY,EAAI6D,EAAG7D,IACpCiD,EAAQjD,CAAC,IAAM,QAAaiD,EAAQjD,CAAC,EAAE,WAEtCkD,IAA0B,IAAQU,EAAIX,EAAQjD,CAAC,EAAE,IAAI,IAAM,OACzD,MAAM,QAAQ4D,EAAIX,EAAQjD,CAAC,EAAE,IAAI,CAAC,EACpC4D,EAAIX,EAAQjD,CAAC,EAAE,IAAI,EAAI4D,EAAIX,EAAQjD,CAAC,EAAE,IAAI,EAAE,OAAOZ,EAAOY,CAAC,CAAC,EAE5D4D,EAAIX,EAAQjD,CAAC,EAAE,IAAI,EAAI,CAAC4D,EAAIX,EAAQjD,CAAC,EAAE,IAAI,EAAGZ,EAAOY,CAAC,CAAC,EAGzD4D,EAAIX,EAAQjD,CAAC,EAAE,IAAI,EAAIZ,EAAOY,CAAC,GAInC,GAAGmB,IAAQ,IAAQvB,IAAS,GAAK,CAC/B,IAAMkE,EAAY,OAAO,OACvB,CAAC,OAAQF,CAAG,EACXzC,IAAQ,GAAO,CAAC,IAAK,KAAK,MAAM,UAAU,SAAShB,CAAQ,CAAC,EAAG,CAAC,EAChEP,IAAS,GAAO,CAAC,KAAM,KAAK,aAAa,CAAC,EAAG,CAAC,CACjD,EACM4C,EAAM,KAAK,OACfmB,IAAY,OAAYG,EAAY,CAACF,EAAID,CAAO,EAAGG,CAAS,EAC1DlD,CAAI,EACR,GAAG4B,EACD,OAAOA,CAEX,KAAK,CACH,IAAMA,EAAM,KAAK,OACfmB,IAAY,OAAYC,EAAM,CAACA,EAAID,CAAO,EAAGC,CAAG,EAC9ChD,CAAI,EACR,GAAG4B,EACD,OAAOA,CAEX,CAEF,SACKrB,IAAQ,IAAQvB,IAAS,GAAK,CAC/B,IAAMkE,EAAY,OAAO,OACvB,CAAC,OAAQ1E,CAAM,EACf+B,IAAQ,GAAO,CAAC,IAAK,KAAK,MAAM,UAAU,SAAShB,CAAQ,CAAC,EAAG,CAAC,EAChEP,IAAS,GAAO,CAAC,KAAM,KAAK,aAAa,CAAC,EAAG,CAAC,CAChD,EACM4C,EAAM,KAAK,OACfmB,IAAY,OAAYG,EAAY,CAAC1E,EAAOuE,CAAO,EAAGG,CAAS,EAC7DlD,CAAI,EACR,GAAG4B,EACD,OAAOA,CAEX,KAAK,CACH,IAAMA,EAAM,KAAK,OACfmB,IAAY,OAAYvE,EAAS,CAACA,EAAOuE,CAAO,EAAGvE,CAAM,EACvDwB,CAAI,EACR,GAAG4B,EACD,OAAOA,CAEX,CAEJ,CACA,KAAK,cAAc,CACrB,EACA,qBAAsB,SAASpD,EAAO,CACpC,GAAM,CAAC,mBAAA2E,CAAkB,EAAI,KAAK,MAClC,GAAG,CACD,IAAMC,EAAUD,IAAuB,OAAY3E,EAAS2E,EAAmB,KAAK,KAAM3E,CAAM,EAChG,GAAG,CAAC,MAAM,QAAQ4E,CAAO,EACvB,OAAO,KAAK,QACV,IAAIvB,EAAS,6BAA8B,CACzC,0BACA,wCACA,OAAO,KAAK,UAAUuB,CAAO,CAAC,EAChC,EAAG,KAAK,QAAS,KAAK,YAAY,EAAG,CACnC,QAASA,CACX,CAAC,CACH,EAEF,IAAMC,EAAoBC,GAAwBF,CAAO,EACzD,KAAK,MAAM,qBAAuBC,EAAkB,OACpD,KAAK,QAAQ,QAAUA,EACvB,KAAK,cAAc,EACnB,MACF,OAAOzB,EAAI,CACT,OAAOA,CACT,CACF,EACA,cAAe,UAAU,CACpB,KAAK,QAAQ,MAAQ,IACtB,KAAK,MAAM,UAAU,MAAM,EAE7B,KAAK,MAAM,MAAQ,OACnB,KAAK,MAAM,OAAS,CAAC,EACrB,KAAK,MAAM,cAAgB,CAC7B,EACA,UAAW,UAAU,CACnB,GAAM,CAAC,KAAA2B,EAAM,SAAAhE,EAAU,MAAAkB,EAAO,gBAAAH,CAAe,EAAI,KAAK,QAChD,CAAC,QAAAsC,EAAS,WAAAY,CAAU,EAAI,KAAK,MAEnC,GAAGZ,IAAY,GACb,OAAO,KAAK,aAAa,EAE3B,IAAInE,EAAQ,KAAK,MAAM,MAAM,SAASc,CAAQ,EAI9C,GAHGkB,IAAU,IAAQ+C,IAAe,KAClC/E,EAAQA,EAAM,UAAU,GAEvB8E,IAAS,GAAK,CACf,GAAM,CAAC3B,EAAK6B,CAAC,EAAI,KAAK,OAAOhF,CAAK,EAClC,GAAGmD,IAAQ,OAAW,OAAOA,EAC7BnD,EAAQgF,CACV,CACA,KAAK,MAAM,OAAO,KAAKhF,CAAK,EAEzB6B,IAAoB,GAAK,OAAO7B,GAAU,WAC3C,KAAK,MAAM,eAAiBA,EAAM,QAEpC,KAAK,aAAa,CACpB,EACA,aAAc,UAAU,CACtB,KAAK,MAAM,MAAM,MAAM,EACvB,KAAK,MAAM,WAAa,EAC1B,EACA,OAAQ,SAASD,EAAQwB,EAAK,CAC5B,GAAM,CAAC,UAAA0D,CAAS,EAAI,KAAK,QACzB,GAAGA,IAAc,OAAU,CACzB,IAAM1E,EAAO,KAAK,aAAa,EAC/B,GAAG,CACDR,EAASkF,EAAU,KAAK,KAAMlF,EAAQQ,CAAI,CAC5C,OAAO4C,EAAI,CACT,OAAOA,CACT,CACA,GAA2BpD,GAAW,KAAO,MAC/C,CACAwB,EAAKxB,CAAM,CACb,EAEA,OAAQ,SAASC,EAAM,CACrB,GAAM,CAAC,QAAA4D,EAAS,mBAAAG,CAAkB,EAAI,KAAK,QAK3C,GAJkB,MAAM,QAAQH,CAAO,IAItB,IAAQG,GAAsB,KAAK,QAAQ,QAAQ,QAAU,KAAK,MAAM,OAAO,OAC9F,MAAO,CAAC,OAAW,MAAS,EAE9B,GAAG,KAAK,MAAM,YAAc,KAC1B,GAAG,CACD,IAAMxD,EAAO,KAAK,YAAY,EAC9B,MAAO,CAAC,OAAW,KAAK,MAAM,UAAU,KAAK,KAAMP,EAAOO,CAAI,CAAC,CACjE,OAAO4C,EAAI,CACT,MAAO,CAACA,CAAG,CACb,CAEF,GAAG,KAAK,UAAUnD,CAAK,EACrB,MAAO,CAAC,OAAW,WAAWA,CAAK,CAAC,EAChC,GAAG,KAAK,QAAQ,YAAc,GAAM,CACxC,IAAMO,EAAO,KAAK,YAAY,EAC9B,MAAO,CAAC,OAAW,KAAK,QAAQ,UAAU,KAAK,KAAMP,EAAOO,CAAI,CAAC,CACnE,CACA,MAAO,CAAC,OAAWP,CAAK,CAC1B,EAEA,iBAAkB,SAAS0C,EAAKE,EAAI,CAYlC,OAXe,CAACF,EAAKE,IAAQ,CAC3B,GAAM,CAAC,SAAAsC,CAAQ,EAAI,KAAK,MACxBC,EAAO,QAAQxE,EAAI,EAAGA,EAAIuE,EAAS,OAAQvE,IAAI,CAC7C,IAAMyE,EAAUF,EAASvE,CAAC,EAC1B,QAAQ0E,EAAI,EAAGA,EAAID,EAAQ,OAAQC,IACjC,GAAGD,EAAQC,CAAC,IAAM3C,EAAIE,EAAIyC,CAAC,EAAG,SAASF,EAEzC,OAAOC,EAAQ,MACjB,CACA,MAAO,EACT,GACc1C,EAAKE,CAAG,CACxB,EAOA,UAAW,SAAS0C,EAAM,CACxB,OAAQA,EAAQ,WAAWA,CAAK,EAAI,GAAM,CAC5C,EACA,eAAgB,SAASC,EAAWC,EAAWC,EAAWC,EAAU,CAClE,GAAGH,EAAU,CAAC,IAAMG,EAAW,MAAO,GACtC,IAAMC,EAAeJ,EAAU,OAC/B,QAAQ5E,EAAI,EAAGA,EAAIgF,EAAchF,IAC/B,GAAG4E,EAAU5E,CAAC,IAAM6E,EAAUC,EAAU9E,CAAC,EAAG,MAAO,GAErD,OAAOgF,CACT,EACA,cAAe,SAASjD,EAAKE,EAAKC,EAAI,CACpC,GAAM,CAAC,UAAA+C,EAAW,uBAAAC,CAAsB,EAAI,KAAK,QACjD,GAAGA,IAA2B,IAAQ,KAAK,MAAM,OAAO,SAAW,KAAK,QAAQ,QAAQ,OAAS,EAC/F,MAAO,GACH,GAAGA,IAA2B,IAAS,OAAOA,GAA2B,UAAY,KAAK,MAAM,OAAO,SAAWA,EAAyB,EAC/I,MAAO,GAETV,EAAO,QAAQxE,EAAI,EAAGA,EAAIiF,EAAU,OAAQjF,IAAI,CAC9C,IAAMmF,EAAMF,EAAUjF,CAAC,EACvB,GAAGmF,EAAI,CAAC,IAAMjD,EAAI,CAChB,QAAQwC,EAAI,EAAGA,EAAIS,EAAI,OAAQT,IAC7B,GAAGS,EAAIT,CAAC,IAAM3C,EAAIE,EAAIyC,CAAC,EAAG,SAASF,EAErC,OAAOW,EAAI,MACb,CACF,CACA,MAAO,EACT,EACA,oBAAqB,SAASjD,EAAKH,EAAKE,EAAI,CAC1C,GAAM,CAAC,iBAAAP,CAAgB,EAAI,KAAK,QAC1BiB,EAAwBjB,EAAiB,OAC/C8C,EAAO,QAAQxE,EAAI,EAAGA,EAAI2C,EAAuB3C,IAAI,CACnD,IAAMoF,EAAK1D,EAAiB1B,CAAC,EACvBqF,EAAWD,EAAG,OACpB,GAAGA,EAAG,CAAC,IAAMlD,EAGb,SAAQwC,EAAI,EAAGA,EAAIW,EAAUX,IAC3B,GAAGU,EAAGV,CAAC,IAAM3C,EAAIE,EAAIyC,CAAC,EACpB,SAASF,EAGb,OAAOY,EAAG,OACZ,CACA,MAAO,EACT,EACA,WAAY,SAASrD,EAAKE,EAAKC,EAAI,CACjC,GAAM,CAAC,OAAA9B,CAAM,EAAI,KAAK,QACtB,GAAGA,IAAW,KAAM,MAAO,GAC3B,IAAMyD,EAAIzD,EAAO,OACjB,GAAGA,EAAO,CAAC,IAAM8B,EAAI,CACnB,QAAQlC,EAAI,EAAGA,EAAI6D,EAAG7D,IACpB,GAAGI,EAAOJ,CAAC,IAAM+B,EAAIE,EAAIjC,CAAC,EACxB,MAAO,GAGX,MAAO,EACT,CACA,MAAO,EACT,EACA,UAAW,SAAS+B,EAAKE,EAAI,CAC3B,GAAM,CAAC,MAAA5B,CAAK,EAAI,KAAK,QACrB,GAAGA,IAAU,KAAM,MAAO,GAC1B,IAAMwD,EAAIxD,EAAM,OAChB,QAAQL,EAAI,EAAGA,EAAI6D,EAAG7D,IACpB,GAAGK,EAAML,CAAC,IAAM+B,EAAIE,EAAIjC,CAAC,EACvB,MAAO,GAGX,MAAO,EACT,EACA,8BAA+B,SAAS+B,EAAKE,EAAI,CAC/C,GAAM,CAAE,SAAA9B,CAAS,EAAI,KAAK,QAIpBmF,EAAM,CAEV7F,EAAO,KAAK;AAAA,EAAQU,CAAQ,EAC5BV,EAAO,KAAK;AAAA,EAAMU,CAAQ,EAC1BV,EAAO,KAAK,KAAMU,CAAQ,CAC5B,EACAoF,EAAM,QAAQvF,EAAI,EAAGA,EAAIsF,EAAI,OAAQtF,IAAI,CACvC,IAAM6D,EAAIyB,EAAItF,CAAC,EAAE,OACjB,QAAQ0E,EAAI,EAAGA,EAAIb,EAAGa,IACpB,GAAGY,EAAItF,CAAC,EAAE0E,CAAC,IAAM3C,EAAIE,EAAMyC,CAAC,EAC1B,SAASa,EAGb,YAAK,QAAQ,iBAAiB,KAAKD,EAAItF,CAAC,CAAC,EACzC,KAAK,MAAM,yBAA2BsF,EAAItF,CAAC,EAAE,OACtCsF,EAAItF,CAAC,EAAE,MAChB,CACA,MAAO,EACT,EACA,QAAS,SAASwF,EAAI,CACpB,GAAM,CAAC,SAAArF,EAAU,IAAAgB,EAAK,wBAAAsE,CAAuB,EAAI,KAAK,QAChDjD,EAAM,OAAOgD,GAAQ,SAAW,IAAI,MAAMA,CAAG,EAAIA,EACvD,GAAGC,EAAwB,CACzB,KAAK,MAAM,eAAiB,GACzB,KAAK,QAAQ,UAAY,QAC1B,KAAK,QAAQ,QAAQjD,EAAKrB,EAAM,KAAK,MAAM,UAAU,SAAShB,CAAQ,EAAI,MAAS,EAGrF,MACF,KACE,QAAOqC,CAEX,EACA,cAAe,UAAU,CACvB,MAAO,CACL,GAAG,KAAK,KACR,QAAS,KAAK,QAAQ,OACxB,CACF,EACA,aAAc,UAAU,CACtB,GAAM,CAAC,QAAAS,EAAS,IAAA9B,EAAK,SAAAhB,CAAQ,EAAI,KAAK,QACtC,MAAO,CACL,GAAG,KAAK,cAAc,EACtB,MAAO,KAAK,MAAM,MAClB,OAAQ8C,IAAY,GACpB,MAAO,KAAK,MAAM,OAAO,OACzB,IAAK9B,EAAM,KAAK,MAAM,UAAU,SAAShB,CAAQ,EAAI,MACvD,CACF,EACA,YAAa,UAAU,CACrB,GAAM,CAAC,QAAA8C,CAAO,EAAI,KAAK,QACjByC,EAAY,MAAM,QAAQzC,CAAO,EACvC,MAAO,CACL,GAAG,KAAK,aAAa,EACrB,OAAQyC,IAAc,GACnBzC,EAAQ,OAAS,KAAK,MAAM,OAAO,OAClCA,EAAQ,KAAK,MAAM,OAAO,MAAM,EAAE,KAClC,KAEF,KAAK,MAAM,OAAO,OACpB,QAAS,KAAK,MAAM,UACtB,CACF,CACF,CACF,EChtBA,IAAM0C,GAAQ,SAASC,EAAMC,EAAK,CAAC,EAAE,CAChC,OAAOD,GAAS,WACjBA,EAAOE,EAAO,KAAKF,CAAI,GAEzB,IAAMG,EAAUF,GAAQA,EAAK,QAAU,CAAC,EAAI,CAAC,EACvCG,EAASC,GAAUJ,CAAI,EACvBK,EAAQC,GAAW,CACpBH,EAAO,QAAQ,UAAY,OAC5BD,EAAQ,KAAKI,CAAM,EAEnBJ,EAAQI,EAAO,CAAC,CAAC,EAAIA,EAAO,CAAC,CAEjC,EACMC,EAAQ,IAAM,CAAC,EACfC,EAAOL,EAAO,MAAMJ,EAAM,GAAOM,EAAME,CAAK,EAClD,GAAGC,IAAS,OAAW,MAAMA,EAC7B,IAAMC,EAAON,EAAO,MAAM,OAAW,GAAME,EAAME,CAAK,EACtD,GAAGE,IAAS,OAAW,MAAMA,EAC7B,OAAOP,CACT,ECpBA,IAAMQ,EAAmB,CACxB,wBAAyB,EACzB,uBAAwB,EACxB,2BAA4B,EAC5B,oBAAqB,CACtB,EAEMC,GAAWC,GAAmC,CACnD,GAAI,CAACA,GAASA,IAAU,GAAI,MAAO,YACnC,GAAI,OAAOA,GAAU,SAAU,MAAO,SACtC,GAAI,OAAOA,GAAU,SAAU,MAAO,SAEtC,GAAI,CAEH,IAAMC,EAAiBD,EACrB,KAAK,EACL,QAAQ,MAAO,EAAE,EACjB,QAAQ,KAAM,GAAG,EACjB,QAAQ,SAAU,GAAG,EACrB,QAAQ,8BAA+B,GAAG,EAE5C,OAAQ,MAAM,OAAOC,CAAc,CAAC,EAAe,SAAX,QACzC,MAAY,CACX,MAAO,QACR,CACD,EAEMC,GAAkB,CAACC,EAAcC,EAAY,MAC3CC,GAAMF,EAAM,CAClB,UAAWC,EACX,iBAAkB,GAClB,QAAS,GACT,QAAS,IACT,mBAAoB,GACpB,wBAAyB,GACzB,KAAM,EACP,CAAC,EAGIE,GAAwBC,GAAoC,CACjE,GAAIA,EAAc,SAAW,EAAG,MAAO,GAEvC,IAAMC,EAAeD,EAAc,KAAK,EAClCE,EAAe,IAAI,IAAID,EAAa,OAAO,OAAO,CAAC,EAEnDE,EAAcF,EAAa,OAGjC,OAFyBC,EAAa,KAEXC,EAAe,GAC3C,EAEMC,GAAkBC,GAAgC,CACvD,IAAMC,EAAgBD,EAAU,OAAQE,GAAYA,GAAWA,IAAY,QAAQ,EAEnF,OAAID,EAAc,SAAW,EAAU,EAE/BA,EAAc,OAASD,EAAU,OAAU,GACpD,EAEMG,GAAqB,CAACH,EAAuBI,IAA4B,CAC9E,IAAMC,EAAeL,EAAU,IAAI,CAACM,EAASC,IACzBD,EAAQ,OAAQJ,GAAYA,IAAYE,EAAMG,CAAM,CAAC,EACrD,OAASD,EAAQ,OAAU,GAC9C,EAID,MAAO,KAFeD,EAAa,OAAQG,GAASA,EAAO,CAAC,EAClB,OAASH,EAAa,OAAU,GAE3E,EAEMI,GAAsB,CAACC,EAAoBC,IAA4B,CAC5E,IAAIC,EAAmB,EAEvB,QAAWC,KAAOH,EACbC,EAAM,SAAWE,EAAI,QAAUF,EAAM,KAAK,GAAG,IAAME,EAAI,KAAK,GAAG,GAClED,IAGF,OAAQA,EAAmBF,EAAO,OAAU,GAC7C,EAEMI,GAAuB,CAC5Bd,EACAe,IACgB,CAChB,IAAMC,EACLD,EAAsB,OAAS,EAC5Bf,EAAU,IAAKa,GAAQA,EAAI,OAAO,CAACI,EAAGC,IAAU,CAACH,EAAsB,SAASG,CAAK,CAAC,CAAC,EACvFlB,EACJ,OAAOgB,EAAe,IAAI,CAACV,EAASC,IAC5BD,EAAQ,IAAI,CAACJ,EAASiB,IAAc,CAC1C,IAAMC,EAAcjC,GAAQe,CAAO,EAEnC,OAAIkB,IAAgB,aAAeb,EAAS,EACpCpB,GAAQ6B,EAAeT,EAAS,CAAC,EAAEY,CAAS,CAAC,EAG9CC,CACR,CAAC,CACD,CACF,EAEaC,GAAe,CAAC9B,EAAcC,EAAY,MAAgB,CACtE,IAAM8B,EAAahC,GAAgBC,EAAMC,CAAS,EAClD,GAAI8B,EAAW,OAAS,EAAG,MAAO,GAElC,IAAMC,EAAUD,EAAW,MAAM,EACjC,GAAI,CAACC,EAAS,MAAO,GAErB,IAAMR,EAAwB,CAAC,EAC/B,QAASS,EAAY,EAAGA,EAAYD,EAAQ,OAAQC,IACpCD,EAAQC,CAAS,GAE/BT,EAAsB,KAAKS,CAAS,EAGtC,IAAM7B,EAAgB4B,EAAQ,OAC5BrB,GAAoBA,GAAWA,IAAY,MAAQA,IAAY,EACjE,EAEMuB,EAAyB,CAAC,EAC5BC,EAAoB,EAClBC,EAA0BjC,GAAqBC,CAAa,EAClE8B,EAAa,KAAKE,GAA2BzC,EAAiB,wBAA0B,EAAE,EAC1FwC,GAAqBxC,EAAiB,wBAA0B,EAEhE,IAAM0C,EAAcjC,EAAc,IAAKkC,GAAW1C,GAAQ0C,CAAM,CAAC,EAC3DC,EAAmBF,EAAY,OAAQC,GAAWA,IAAW,WAAW,EAExEE,EAAyBhC,GAC9B+B,EAAiB,OAAS,EAAIA,EAAmBF,CAClD,EACAH,EAAa,KAAKM,GAA0B7C,EAAiB,uBAAyB,EAAE,EACxFwC,GAAqBxC,EAAiB,uBAAyB,EAE/D,IAAM8C,EAAiBV,EAAW,CAAC,EAAE,IAAI,CAACL,EAAGgB,IAAaX,EAAW,IAAKT,GAAQA,EAAIoB,CAAQ,CAAC,CAAC,EAC1FC,EAAwB/B,GAAmB6B,EAAgBT,CAAO,EACxEE,EAAa,KAAKS,GAAyBhD,EAAiB,2BAA6B,EAAE,EAC3FwC,GAAqBxC,EAAiB,2BAA6B,EAEnE,IAAMiD,EAAYrB,GAAqBQ,EAAYP,CAAqB,EAClEqB,EAAsB3B,GAAoB0B,EAAWP,CAAW,EACtE,OAAAH,EAAa,KAAKW,GAAuBlD,EAAiB,oBAAsB,EAAE,EAClFwC,GAAqBxC,EAAiB,oBAAsB,EAErDuC,EAAa,OAAO,CAACY,EAAGC,IAAMD,EAAIC,CAAC,EAAIZ,EAAoB,GACnE,ECpJO,IAAMa,GAAmBC,GAAyB,CACxD,IAAIC,EAAUD,EAEdC,EAAUA,EAAQ,QAAQ,OAAQ,EAAE,EAEpCA,EAAUA,EAAQ,QAAQ,UAAW,GAAG,EAExCA,EAAUA,EAAQ,QAAQ,eAAgB,EAAE,EAE5C,IAAMC,EAAQD,EAAQ,MAAM,QAAQ,EAChCC,EAAM,GAAG,EAAE,IAAM,IACpBA,EAAM,IAAI,EAGX,IAAMC,EAAqB,CAAC,IAAM,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAClEC,EAAqC,CAAC,EACtCC,EAA4C,CAAC,EAEnDH,EAAM,QAASI,GAAS,CACvBH,EAAmB,QAASI,GAAc,CACzC,IAAMC,EAAQF,EAAK,MAAMC,CAAS,EAAE,OAChCC,IAAU,IAETJ,EAAQG,CAAS,IACrBH,EAAQG,CAAS,EAAI,EACrBF,EAAaE,CAAS,EAAI,CAAC,GAG5BH,EAAQG,CAAS,GAAKC,EAAQ,EAC9BH,EAAaE,CAAS,EAAE,KAAKC,EAAQ,CAAC,EACvC,CAAC,CACF,CAAC,EAED,IAAMC,EAAqB,OAAO,KAAKL,CAAO,EAC9C,GAAIK,EAAmB,SAAW,EACjC,OAAOA,EAAmB,CAAC,EAG5B,IAAMC,EAAiBC,GACTA,EAAO,OAAO,CAACC,EAAKC,IAAYD,EAAMC,CAAO,EAAIF,EAAO,OAIhEG,EAAqBH,GAA6B,CACvD,IAAMI,EAAUL,EAAcC,CAAM,EAC9BK,EAAcL,EAAO,IAAKM,GAA0B,CACzD,IAAMC,EAAOD,EAAQF,EACrB,OAAOG,EAAOA,CACf,CAAC,EAGD,OADiBR,EAAcM,CAAW,CAE3C,EAEMG,EAAeC,GACb,KAAK,KAAKA,CAAQ,EAGpBC,EAAmB,OAAO,KAAKhB,CAAY,EAC/C,IAAKiB,GAAQ,CACb,IAAMhB,EAAOD,EAAaiB,CAAG,EAEvBF,EAAWN,EAAkBR,CAAI,EACjCiB,EAAKJ,EAAYC,CAAQ,EAC/B,MAAO,CAAE,UAAWE,EAAK,MAAOC,CAAG,CACpC,CAAC,EACA,OAAQA,GAAOA,EAAG,MAAQ,EAAG,EAC7B,KAAMC,GAAYA,EAAQ,KAAK,EAEjC,GAAIH,EAAiB,SAAW,EAC/B,OAAOA,EAAiB,CAAC,EAAE,UAG5B,GAAIA,EAAiB,OAAS,EAAG,CAChC,IAAMI,EAAgBJ,EAAiB,IAAKG,GAAYA,EAAQ,SAAS,EACzErB,EAAmB,QAASI,GAAc,CACzC,GAAIkB,EAAc,SAASlB,CAAS,EACnC,OAAOA,CAET,CAAC,CACF,CAEA,MAAO,GACR,ECtBO,IAAMmB,GAAN,KAAmC,CACjC,MAAyB,KACzB,SAA4B,KAC5B,YAAc,GACd,UAAY,GACZ,WAAa,GACb,mBAAqB,SACrB,qBAAuB,GACvB,mBAAqB,IAEtB,cAAyB,CAC/B,SAAU,OACX,EAEA,KAAO,CACN,KAAM,WACP,EAEA,IAAI,WAAqB,CACxB,OAAO,KAAK,SACb,CAEA,IAAI,MAAwB,CAC3B,OAAO,KAAK,KACb,CAEA,IAAI,WAAoB,CACvB,OAAO,KAAK,cAAc,WAAW,SAAS,GAAK,GACpD,CAEA,IAAI,mBAA4B,CAC/B,OAAO,KAAK,kBACb,CAEA,IAAI,KAAM,CACT,MAAO,CACN,UAAW,KAAK,UAChB,UAAW,KAAK,UAChB,kBAAmB,KAAK,kBACxB,KAAM,KAAK,IACZ,CACD,CAEA,IAAI,OAAqB,CACxB,YAAK,SAAW,KAChB,KAAK,YAAc,GACnB,KAAK,UAAY,GACjB,KAAK,WAAa,GAClB,KAAK,mBAAqB,SAC1B,KAAK,cAAgB,CACpB,SAAU,OACX,EAEO,CACN,iBAAkB,OAAO,OACxB,MAAOC,EAA8BC,IAAqB,CACzD,GAAI,CAAC,MAAM,QAAQD,EAAI,MAAM,EAAG,CAC/BC,EAAK,EACL,MACD,CAEA,OAAW,CAAE,OAAAC,CAAO,IAAKF,EAAI,OAAQ,CAGpC,GAFI,CAACE,GAAU,EAAE,SAAUA,IAAW,CAACA,EAAO,MAE1C,EAAE,QAASA,EAAO,OAAS,CAACA,EAAO,KAAK,IAAK,SAEjD,IAAMC,EAAuBD,EAAO,KAAK,IACzC,GAAI,IAAE,QAASC,IAAe,EAAE,YAAaA,IAE7C,CAAI,YAAaA,GAAcA,EAAW,SACzC,KAAK,YAAYA,EAAW,OAAO,EAEpC,GAAI,CACH,IAAMC,EAAO,MAAM,KAAK,MAAMD,EAAW,KAAOA,EAAW,SAAW,EAAE,EACxE,GAAI,CAACC,GAAQ,EAAE,WAAYA,IAAS,CAACA,EAAK,OACzC,MAAM,IAAI,MAAM,cAAc,EAG/B,GAAI,CAAC,KAAK,WAAa,CAAC,KAAK,YAC5B,MAAM,IAAI,MAAM,wBAAwB,EAEzCF,EAAO,KAAOE,CACf,OACOC,EAAgB,CAClBA,aAAiB,OACpB,QAAQ,MAAMA,EAAM,OAAO,EAE5B,QACD,EAED,CACAJ,EAAK,CACN,EACA,CAAE,SAAU,IAAM,CACnB,CACD,CACD,CAEQ,YAAYK,EAAuB,CACtC,cAAeA,GAAWA,EAAQ,YACrC,KAAK,cAAc,UAAYA,EAAQ,WAGpC,aAAcA,GAAWA,EAAQ,WACpC,KAAK,cAAc,SAAWA,EAAQ,UAGnC,cAAeA,GAAWA,EAAQ,YACrC,KAAK,WAAaA,EAAQ,UAC1B,KAAK,UAAY,IAGd,YAAaA,GAAWA,EAAQ,SAAW,MAAM,QAAQA,EAAQ,OAAO,IAC3E,KAAK,SAAWA,EAAQ,SAGrB,eAAgBA,GAAWA,EAAQ,aACtC,KAAK,YAAcA,EAAQ,YAExB,sBAAuBA,GAAWA,EAAQ,oBAC7C,KAAK,mBAAqBA,EAAQ,kBAEpC,CAEO,eAAeF,EAA0B,CAC/C,MAAI,CAACA,GAAQ,EAAE,WAAYA,IAAS,CAACA,EAAK,SAE1CA,EAAK,OAASA,EAAK,OAAO,IACxBG,IAKC,WAAYA,GACZA,EAAK,QACLA,EAAK,OAAO,MAAOC,GAA2B,CAAC,MAAM,OAAOA,CAAK,CAAC,CAAC,IAEnED,EAAK,OAASA,EAAK,OAAO,IAAKC,GAA2B,OAAOA,CAAK,CAAC,GAEjED,EAET,GACOH,CACR,CAEA,MAAa,MAAMK,EAAeH,EAAmB,CAAC,EAAGI,EAAU,GAAgC,CAQlG,MAPI,CAACD,IAEDH,IACH,KAAK,cAAgB,CAAE,GAAG,KAAK,cAAe,GAAGA,CAAQ,GAE1D,MAAM,KAAK,UAAUG,CAAK,EAEtB,CAAC,KAAK,MAAa,KAElBC,EAEE,KAAK,eAAe,KAAK,IAAI,EAFf,KAAK,IAG3B,CAEA,MAAa,UAAUC,EAAgB,CAClCA,EAAO,WAAW,MAAM,IAC3BA,EAAS,MAAM,KAAK,UAAUA,CAAM,GAGrC,IAAMC,EAAY,KAAK,aAAaD,CAAM,EAI1C,GAHA,KAAK,cAAc,UAAYC,EAE/B,KAAK,UAAY,GACb,CAAC,KAAK,YAAc,CAAC,MAAM,QAAQ,KAAK,QAAQ,EAAG,CACtD,IAAMC,EAAoBC,GAAaH,EAAQC,CAAS,EACpDC,EAAoB,KAAK,uBAC5B,QAAQ,MAAM,yBAA0BA,CAAiB,EACzD,KAAK,UAAY,GAEnB,CACA,GAAI,CACH,IAAME,EAAcC,GAAML,EAAQ,CACjC,iBAAkB,GAClB,QAAS,IACT,mBAAoB,GACpB,wBAAyB,GACzB,GAAG,KAAK,aACT,CAAC,EACD,KAAK,MAAQ,KAAK,WAAWI,CAAW,CACzC,OAASV,EAAgB,CACpBA,aAAiB,OACpB,QAAQ,MAAMA,EAAM,OAAO,EAE5B,KAAK,MAAQ,KACb,MACD,CACD,CAEA,MAAa,UAAUY,EAA8B,CACpD,IAAMC,EAAW,MAAM,MAAMD,CAAG,EAChC,OAAKC,EAAS,GAIP,MAAMA,EAAS,KAAK,GAH1B,QAAQ,MAAM,4BAA4BD,CAAG,EAAE,EACxC,GAGT,CAEO,aAAab,EAAsB,CACzC,YAAK,mBAAqBe,GAAgBf,CAAI,EACvC,KAAK,cAAc,WAAW,SAAS,GAAK,KAAK,kBACzD,CAEQ,WAAWgB,EAAsC,CACxD,GAAIA,EAAQ,SAAW,EACtB,OAAO,KAER,IAAMC,EAAmB,MAAM,QAAQ,KAAK,QAAQ,EAAI,KAAK,SAAW,KAAK,WAAWD,CAAO,EACzFE,EAAS,CAAC,EAChB,QAASC,EAAS,EAAGA,EAASH,EAAQ,CAAC,EAAE,OAAQG,IAAU,CAC1D,IAAMC,EACLH,EAAOE,CAAM,GAAKF,EAAOE,CAAM,EAAE,OAAS,EAAIF,EAAOE,CAAM,EAAI,KAAK,oBAAsBA,EAAS,GAEpGD,EAAO,KAAK,CACX,KAAME,EAAW,KAAK,EACtB,OAAQJ,EAAQ,IAAKK,GAAWA,EAAOF,CAAM,GAAK,EAAE,CACrD,CAAC,CACF,CACA,MAAO,CAAE,OAAQD,CAAO,CACzB,CAEQ,WAAWF,EAA+B,CACjD,IAAIM,EAA2B,CAAC,EAChC,OAAI,KAAK,WAAaN,EAAQ,OAAS,GAAKA,EAAQ,CAAC,EAAE,OAAS,IAC/DM,EAAiBN,EAAQ,MAAM,GAAK,CAAC,EACjCM,EAAe,OAAS,GACpBA,EAAe,IAAI,CAACnB,EAAMoB,IAChCpB,EAAK,SAAW,EAAI,KAAK,oBAAsBoB,EAAM,GAAKpB,CAC3D,EAIK,OAAO,KAAKa,EAAQ,CAAC,CAAC,EAAE,IAAKO,GAAQ,KAAK,oBAAsB,SAASA,CAAG,EAAI,EAAE,CAC1F,CACD,EC1SO,IAAMC,GAAN,cAAwBC,EAAW,CAAC,EAEpCC,GAAQF",
  "names": ["exports$3", "_dewExec$2", "dew$2", "byteLength", "toByteArray", "fromByteArray", "lookup", "revLookup", "Arr", "code", "i", "len", "getLens", "b64", "validLen", "placeHoldersLen", "lens", "_byteLength", "tmp", "arr", "curByte", "tripletToBase64", "num", "encodeChunk", "uint8", "start", "end", "output", "extraBytes", "parts", "maxChunkLength", "len2", "exports$2", "_dewExec$1", "dew$1", "buffer", "offset", "isLE", "mLen", "nBytes", "e", "m", "eLen", "eMax", "eBias", "nBits", "d", "s", "value", "c", "rt", "exports$1", "_dewExec", "dew", "base64", "ieee754", "customInspectSymbol", "Buffer", "SlowBuffer", "K_MAX_LENGTH", "typedArraySupport", "proto", "createBuffer", "length", "buf", "arg", "encodingOrOffset", "allocUnsafe", "from", "fromString", "fromArrayView", "isInstance", "fromArrayBuffer", "valueOf", "b", "fromObject", "assertSize", "size", "alloc", "fill", "encoding", "checked", "string", "actual", "fromArrayLike", "array", "arrayView", "copy", "byteOffset", "obj", "numberIsNaN", "a", "x", "y", "list", "pos", "mustMatch", "loweredCase", "utf8ToBytes", "base64ToBytes", "slowToString", "hexSlice", "utf8Slice", "asciiSlice", "latin1Slice", "base64Slice", "utf16leSlice", "swap", "n", "str", "max", "target", "thisStart", "thisEnd", "thisCopy", "targetCopy", "bidirectionalIndexOf", "val", "dir", "arrayIndexOf", "indexSize", "arrLength", "valLength", "read", "foundIndex", "found", "j", "hexWrite", "remaining", "strLen", "parsed", "utf8Write", "blitBuffer", "asciiWrite", "asciiToBytes", "base64Write", "ucs2Write", "utf16leToBytes", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "MAX_ARGUMENTS_LENGTH", "codePoints", "ret", "out", "hexSliceLookupTable", "bytes", "newBuf", "checkOffset", "ext", "noAssert", "mul", "defineBigIntMethod", "validateNumber", "first", "last", "boundsError", "lo", "hi", "checkInt", "min", "maxBytes", "wrtBigUInt64LE", "checkIntBI", "wrtBigUInt64BE", "limit", "sub", "checkIEEE754", "writeFloat", "littleEndian", "writeDouble", "targetStart", "errors", "E", "sym", "getMessage", "Base", "name", "range", "input", "msg", "received", "addNumericalSeparator", "checkBounds", "type", "INVALID_BASE64_RE", "base64clean", "units", "leadSurrogate", "byteArray", "src", "dst", "alphabet", "table", "i16", "fn", "BufferBigIntNotDefined", "exports", "INSPECT_MAX_BYTES", "kMaxLength", "CsvError", "_CsvError", "code", "message", "options", "contexts", "context", "key", "value", "Buffer", "is_object", "obj", "normalize_columns_array", "columns", "normalizedColumns", "i", "l", "column", "is_object", "CsvError", "ResizeableBuffer", "size", "Buffer", "val", "length", "buf", "encoding", "ResizeableBuffer_default", "np", "cr", "nl", "space", "tab", "init_state", "options", "Buffer", "ResizeableBuffer_default", "delimiter", "v", "underscore", "str", "_", "match", "normalize_options", "opts", "options", "opt", "underscore", "CsvError", "value", "date", "normalize_columns_array", "Buffer", "delimiter_json", "delimiter", "rd", "i", "isRecordEmpty", "record", "field", "cr", "nl", "boms", "Buffer", "transform", "original_options", "info", "options", "normalize_options", "init_state", "i", "bufLen", "end", "encoding", "escape", "quote", "quoting", "needMoreDataSize", "recordDelimiterMaxLength", "numOfCharLeft", "requiredLength", "nextBuf", "push", "close", "bom", "comment_no_infix", "from_line", "ltrim", "max_record_size", "raw", "relax_quotes", "rtrim", "skip_empty_lines", "to", "to_line", "comment", "record_delimiter", "bomSkipped", "previousBuf", "rawBuffer", "escapeIsQuote", "buf", "bomLength", "pos", "chr", "nextChr", "isNextChrTrimable", "isNextChrComment", "isNextChrDelimiter", "isNextChrRecordDelimiter", "err", "CsvError", "b", "recordDelimiterLength", "errField", "errRecord", "delimiterLength", "lappend", "rappend", "columns", "group_columns_by_name", "from", "relax_column_count", "relax_column_count_less", "relax_column_count_more", "skip_records_with_empty_values", "enabled", "recordLength", "finalErr", "objname", "obj", "l", "extRecord", "firstLineToHeaders", "headers", "normalizedHeaders", "normalize_columns_array", "cast", "wasQuoting", "f", "on_record", "timchars", "loop1", "timchar", "j", "value", "sourceBuf", "targetBuf", "targetPos", "firstByte", "sourceLength", "delimiter", "ignore_last_delimiters", "del", "rd", "rdLength", "rds", "loop", "msg", "skip_records_with_error", "isColumns", "parse", "data", "opts", "Buffer", "records", "parser", "transform", "push", "record", "close", "err1", "err2", "IMPORTANCEWEIGHT", "getType", "value", "formattedValue", "simpleParseData", "data", "delimiter", "parse", "percentOfUniqueItems", "clearedHeader", "flattenedArr", "uniqueValues", "totalValues", "percentOfTypes", "rowValues", "filteredItems", "element", "percentOfFrequency", "items", "existsCounts", "rowData", "rowKey", "item", "percentOfDifference", "values", "types", "nonMatchingCount", "row", "convertValuesToTypes", "missingHeaderElements", "filteredValues", "_", "index", "dataIndex", "currentType", "headerDetect", "parsedData", "headers", "headerKey", "probabilites", "probabilitesCount", "uniqueHeaderProbalility", "headerTypes", "header", "clearHeaderTypes", "headerTypesProbability", "transposedData", "colIndex", "headerFreqProbability", "dataTypes", "dataTypesDifference", "a", "b", "delimiterDetect", "data", "content", "lines", "standardDelimiters", "results", "resultByLine", "line", "delimiter", "count", "possibleDelimiters", "calculateMean", "values", "sum", "current", "calculateVariance", "average", "squareDiffs", "value", "diff", "calculateSD", "variance", "varianceElements", "key", "sd", "element", "variancedKeys", "DataParser", "ctx", "next", "target", "csvOptions", "data", "error", "options", "item", "value", "input", "convert", "source", "delimiter", "headerProbability", "headerDetect", "parsedInput", "parse", "url", "response", "delimiterDetect", "records", "header", "series", "column", "headerName", "record", "headerResponse", "key", "CSVParser", "DataParser", "src_default"]
}
